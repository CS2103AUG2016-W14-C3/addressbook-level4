# A0140047U
###### \java\taskle\commons\events\storage\StorageChangedEvent.java
``` java
/** Indicates the Storage Location of the application has changed*/
public class StorageChangedEvent extends BaseEvent {

    private TaskManagerStorage data;
    
    public StorageChangedEvent(TaskManagerStorage data){
        this.data = data;
    }
    
    @Override
    public String toString() {
        return "Directory Changed: " + data.getTaskManagerFilePath();
    }
    
    public String getChangedDirectory() {
        return data.getTaskManagerFilePath();
    }
}
```
###### \java\taskle\commons\util\StorageUtil.java
``` java
//Manage changes in directory of storage file
public class StorageUtil {
    
    private static Stack<Config> configHistory = new Stack<Config>();
    private static Stack<Config> redoConfigHistory = new Stack<Config>();
    
    public static boolean updateDirectory(File selectedDirectory) {
        assert selectedDirectory != null;
        try {
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            new File(selectedDirectory.getAbsolutePath(), config.getTaskManagerFileName()).delete();
            new File(config.getTaskManagerFilePath()).renameTo(new File(selectedDirectory.getAbsolutePath(), config.getTaskManagerFileName()));
            config.setTaskManagerFileDirectory(selectedDirectory.getAbsolutePath());
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
            EventsCenter.getInstance().post(new StorageChangeRequestEvent(config.getTaskManagerFilePath(),null));
            return true;
        } catch (IOException | DataConversionException e) {
            return false;
        }
    }
    
    public static boolean updateFile(File selectedFile) {
        assert selectedFile != null;
        ReadOnlyTaskManager newTaskManager;
        try {
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            newTaskManager = XmlFileStorage.loadDataFromSaveFile(selectedFile);
            config.setTaskManagerFileDirectory(splitFilePath(selectedFile.getAbsolutePath())[0]);
            config.setTaskManagerFileName(splitFilePath(selectedFile.getAbsolutePath())[1]);
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
            EventsCenter.getInstance().post(new StorageChangeRequestEvent(config.getTaskManagerFilePath(), newTaskManager));
            return true;
        } catch (IOException | DataConversionException e) {
            return false;
        }
    }
    
    public static String[] splitFilePath(String filePath) {
        assert filePath != null;
        String[] separatedFilePath = new String[2];
        separatedFilePath[0] = filePath.substring(0, filePath.lastIndexOf(File.separator));
        separatedFilePath[1] = filePath.substring(filePath.lastIndexOf(File.separator) + 1);
        return separatedFilePath;
    }
    
    public static void storeConfig(boolean isStorageOperation) throws DataConversionException {
        System.out.println(isStorageOperation);
        if (isStorageOperation) {
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            configHistory.push(config);
        } else {
            redoConfigHistory.clear();
            configHistory.push(null);
        }
    }
    
    public static boolean restoreConfig() throws DataConversionException {
        if (configHistory.isEmpty()) {
            return false;
        }
        Config originalConfig = configHistory.pop();
        Config currentConfig = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
        redoConfigHistory.push(currentConfig);
        
        if (originalConfig == null) {
            redoConfigHistory.push(null);
            return false;
        } else if (originalConfig.getTaskManagerFileName().equals(currentConfig.getTaskManagerFileName())) {
            updateDirectory(new File(originalConfig.getTaskManagerFileDirectory()));
        } else {
            updateFile(new File(originalConfig.getTaskManagerFilePath()));
        }
        return true;
    }
    
    public static boolean revertConfig() throws DataConversionException {
        if (redoConfigHistory.isEmpty()) {
            return false;
        }
        Config redoConfig = redoConfigHistory.pop();
        Config currentConfig = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
        configHistory.push(currentConfig);
        
        if (redoConfig == null) {
            configHistory.push(null);
            return false;
        } else if (redoConfig.getTaskManagerFileName().equals(currentConfig.getTaskManagerFileName())) {
            updateDirectory(new File(redoConfig.getTaskManagerFileDirectory()));
        } else {
            updateFile(new File(redoConfig.getTaskManagerFilePath()));
        }
        return true;
    }
}
```
###### \java\taskle\logic\commands\ChangeDirectoryCommand.java
``` java
//Change directory of current storage file
public class ChangeDirectoryCommand extends Command {

    public static final String COMMAND_WORD = "changedirectory";
    public static final String COMMAND_WORD_SHORT = "cd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Reads data from specified file.\n"
            + "Format: add directory\n"
            + "Example: " + COMMAND_WORD + " C:" + File.separator + "Users" + File.separator + "John"
            + File.separator + "desktop";

    public static final String MESSAGE_SUCCESS = "Storage Directory has been changed to %1$s";
    
    public static final String MESSAGE_FAILURE = "An error occurred when changing directory.";
    
    private final File file;
    
    public ChangeDirectoryCommand(String directoryPath) {
        file = new File(directoryPath);
    }
    
    @Override
    public CommandResult execute() {
        try {
            StorageUtil.storeConfig(true);
            if (StorageUtil.updateDirectory(file)) {
                return new CommandResult(String.format(MESSAGE_SUCCESS, file.getAbsolutePath()), true);
            } else {
                indicateAttemptToExecuteIncorrectCommand(MESSAGE_FAILURE);
                return new CommandResult(MESSAGE_FAILURE, false);
            }
        } catch (DataConversionException e) {
            e.printStackTrace();
            return new CommandResult(MESSAGE_FAILURE, false);
        }
       
    }

}
```
###### \java\taskle\logic\commands\OpenFileCommand.java
``` java
//Opens data from specified file
public class OpenFileCommand extends Command {
    
    public static final String COMMAND_WORD = "openfile";
    public static final String COMMAND_WORD_SHORT = "of";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Reads data from specified file.\n"
            + "Format: add file_path\n"
            + "Example: " + COMMAND_WORD + " C:" + File.separator + "Users" + File.separator + "John"
            + File.separator + "desktop" + File.separator + "taskle.xml";

    public static final String MESSAGE_SUCCESS = "Storage File has been changed.";
    
    public static final String MESSAGE_FAILURE = "Invalid file format detected. Unable to open file";
    
    private final File file;
    
    public OpenFileCommand(String filePath) {
        this.file = new File(filePath);
    }
    
    @Override
    public CommandResult execute() {
        try {
            StorageUtil.storeConfig(true);
            if (StorageUtil.updateFile(file)) {
                return new CommandResult(MESSAGE_SUCCESS, true);
            } else {
                indicateAttemptToExecuteIncorrectCommand(MESSAGE_FAILURE);
                return new CommandResult(MESSAGE_FAILURE, false);
            }
        } catch (DataConversionException e) {
            e.printStackTrace();
            return new CommandResult(MESSAGE_FAILURE, false);
        }
        
    }
    
}
```
###### \java\taskle\logic\commands\RedoCommand.java
``` java
/**
 * Redo recent command entered.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    
    public static final String COMMAND_WORD_SHORT = "r";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Redoes a command that was previously undone." + "Example: "
            + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Redid Undone Command.";
    
    public static final String MESSAGE_NOTHING_TO_REDO = "There is Nothing to Redo.";
    
    public RedoCommand() {
        
    }
    
    @Override
    public CommandResult execute() {
        if (!model.revertTaskManager()) {
            return new CommandResult(MESSAGE_NOTHING_TO_REDO, true);
        }
        return new CommandResult(MESSAGE_SUCCESS, true);
    }
    
}
```
###### \java\taskle\logic\commands\UndoCommand.java
``` java
/**
 * Undo recent command entered.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    
    public static final String COMMAND_WORD_SHORT = "u";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undoes the most recent command." + "\n\nExample: "
            + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Restored Previous Command!";
    
    public static final String MESSAGE_EMPTY_HISTORY = "There is Nothing to Undo!";
    
    public UndoCommand() {
        
    }
    
    @Override
    public CommandResult execute() {
        if (!model.restoreTaskManager()) {
            return new CommandResult(MESSAGE_EMPTY_HISTORY, true);
        }
        return new CommandResult(MESSAGE_SUCCESS, true);
    }
    
}
```
###### \java\taskle\logic\Logic.java
``` java
    /** Updates directory to given filePath */
    void changeDirectory(String filePath);
    
    List<Task> verifyReminder(Date currentDateTime);
    
    void dismissReminder(Date currentDateTime);

    /** Resets Model based on given data */
    void resetModel(ReadOnlyTaskManager taskManager);
    
    //Changes directory and reset model, if necessary
    void handleStorageChangeRequestEvent(StorageChangeRequestEvent srce);
}
```
###### \java\taskle\logic\LogicManager.java
``` java
    @Override
    public void changeDirectory(String filePath) {
        logger.info("----------------[CHANGE DIRECTORY][" + filePath + "]");
        storage.setTaskManagerFilePath(filePath);
    }

    @Override
    public List<Task> verifyReminder(Date currentDateTime) {
        return model.verifyRemindDate(currentDateTime);
    }
    
    @Override
    public void dismissReminder(Date currentDateTime) {
        model.dismissReminder(currentDateTime);
    }
    
    @Override
    public void resetModel(ReadOnlyTaskManager taskManager) {
        model.resetData(taskManager);
    }
    
    @Override
    @Subscribe
    public void handleStorageChangeRequestEvent(StorageChangeRequestEvent scre) {
        changeDirectory(scre.getDirectory());
        if (scre.getTaskManager() != null) {
            resetModel(scre.getTaskManager());
        }
    }
}
```
###### \java\taskle\logic\parser\ChangeDirectoryCommandParser.java
``` java
//ChangeDirectoryParser class to handle parsing of change directory commands
public class ChangeDirectoryCommandParser extends CommandParser {

    @Override
    public Command parseCommand(String args) {
        return parseChangeDirectory(args.trim());
    }
    
    /**
     * Checks if argument is a directory and the directory exists
     * @param directory path of the directory
     * @return ChangeDirectoryCommand if directory is valid, IncorrectCommand otherwise
     */
    public Command parseChangeDirectory(String directory) {
        if (FileUtil.isDirectoryExists(new File(directory))) {
            return new ChangeDirectoryCommand(directory);
        } else {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  ChangeDirectoryCommand.MESSAGE_USAGE));
        }
    }

    @Override
    public boolean canParse(String commandWord) {
        return commandWord.equals(ChangeDirectoryCommand.COMMAND_WORD)
               || commandWord.equals(ChangeDirectoryCommand.COMMAND_WORD_SHORT);
    }

}
```
###### \java\taskle\logic\parser\OpenFileCommandParser.java
``` java
//OpenFileParser class to handle parsing of open file commands
public class OpenFileCommandParser extends CommandParser {

    @Override
    public Command parseCommand(String args) {
        return parseOpenFile(args.trim());
    }
    
    private Command parseOpenFile(String filePath) {
        if (FileUtil.isFileExists(new File(filePath))) {
            return new OpenFileCommand(filePath);
        } else {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  OpenFileCommand.MESSAGE_USAGE));
        }
    }

    @Override
    public boolean canParse(String commandWord) {
        return commandWord.equals(OpenFileCommand.COMMAND_WORD)
               || commandWord.equals(OpenFileCommand.COMMAND_WORD_SHORT);
    }

}
```
###### \java\taskle\logic\parser\RedoCommandParser.java
``` java
/**
 * RedoCommandParser class to handle parsing of redo commands
 */
public class RedoCommandParser extends CommandParser {

    public RedoCommandParser() {
        
    }
    
    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(RedoCommand.COMMAND_WORD)
                || commandWord.equals(RedoCommand.COMMAND_WORD_SHORT);
    }

    @Override
    public Command parseCommand(String args) {
        return new RedoCommand();
    }
}
```
###### \java\taskle\logic\parser\UndoCommandParser.java
``` java
/**
 * UndoCommandParser class to handle parsing of undo commands
 */
public class UndoCommandParser extends CommandParser {

    public UndoCommandParser() {
        
    }
    
    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(UndoCommand.COMMAND_WORD)
               || commandWord.equals(UndoCommand.COMMAND_WORD_SHORT);
    }

    @Override
    public Command parseCommand(String args) {
        return new UndoCommand();
    }

}
```
###### \java\taskle\model\Model.java
``` java
    /** Stores current TaskManager state */
    void storeTaskManager();
    
    /** Restores most recently stored TaskManager state */
    boolean restoreTaskManager();
    
    /** Undo most recently restored TaskManager state */
    boolean revertTaskManager();
    
```
###### \java\taskle\model\ModelManager.java
``` java
    /** Stores current TaskManager state */
    @Override
    public synchronized void storeTaskManager() {
        taskManagerHistory.push(new TaskManager(taskManager));
        redoTaskManagerHistory.clear();
        
        try {
            StorageUtil.storeConfig(false);
        } catch (DataConversionException e) {
            e.printStackTrace();
        }
    }
    
    /** Restores recently saved TaskManager state*/
    @Override
    public synchronized boolean restoreTaskManager() {
        try {
            if (StorageUtil.restoreConfig()) {
                return true;
            } else if (!taskManagerHistory.isEmpty()) {
                TaskManager recentTaskManager = taskManagerHistory.pop();
                redoTaskManagerHistory.push(new TaskManager(taskManager));
                this.resetData(recentTaskManager);
                return true;
            }
            return false;
        } catch (DataConversionException e) {
            e.printStackTrace();
            return false;
        }
    }
    
    /** Reverts changes made from restoring recently saved TaskManager state */
    @Override
    public synchronized boolean revertTaskManager() {
        try {
            if (StorageUtil.revertConfig()) {
                return true;
            } else if (!redoTaskManagerHistory.isEmpty()) {
                TaskManager redoTaskManager = redoTaskManagerHistory.pop();
                taskManagerHistory.push(new TaskManager(taskManager));
                this.resetData(redoTaskManager);
                return true;
            }
            return false;
        } catch (DataConversionException e) {
            e.printStackTrace();
            return false;
        }
    }
    
```
###### \java\taskle\model\task\TaskComparator.java
``` java
/**
 * Custom Comparator that compares tasks when being sorted in internalList
 *
 */
public class TaskComparator implements Comparator<Task> {
    
    private static final int PRIORITY_OVERDUE = 3;
    private static final int PRIORITY_PENDING = 2;
    private static final int PRIORITY_FLOAT = 1;
    private static final int PRIORITY_DONE = 0;

    @Override
    public int compare(Task mainTask, Task taskToCompare) {
        assert mainTask != null && taskToCompare != null;
        
        /**
         * Compare by Type followed by Name/Date
         * Priority of Type: Overdue > Pending > FloatTask > Done
         */
        Status mainStatus = mainTask.getStatus();
        Status otherStatus = taskToCompare.getStatus();
        int mainPriority = getPriority(mainStatus);
        int otherPriority = getPriority(otherStatus);
        
        if (mainPriority > otherPriority) {
            return -1;
        } else if (mainPriority < otherPriority) {
            return 1;
        } else {
            return compareEqualPriorities(mainTask, taskToCompare);
        }
    }
    
    private int compareEqualPriorities(Task mainTask, Task taskToCompare) {
        if (mainTask instanceof FloatTask && taskToCompare instanceof FloatTask) {
            return mainTask.getName().fullName.toLowerCase().compareTo(taskToCompare.getName().fullName.toLowerCase());
        } else if (mainTask instanceof FloatTask) {
            return 1;
        } else if (taskToCompare instanceof FloatTask) {
            return -1;
        } else if (mainTask instanceof DeadlineTask) {
            if (taskToCompare instanceof DeadlineTask) {
                return ((DeadlineTask) mainTask).getDeadlineDate().compareTo(((DeadlineTask) taskToCompare).getDeadlineDate());
            } else {
                return ((DeadlineTask) mainTask).getDeadlineDate().compareTo(((EventTask) taskToCompare).getStartDate());
            }
        } else {
           if (taskToCompare instanceof EventTask) {
               return ((EventTask) mainTask).getStartDate().compareTo(((EventTask) taskToCompare).getStartDate());
           } else {
               return ((EventTask) mainTask).getStartDate().compareTo(((DeadlineTask) taskToCompare).getDeadlineDate());
           }
        }
    }
        
    /**
     * Maps status values to their priority for sorting
     * @param status Status enum as defined in ReadOnlyTask
     * @return
     */
    private int getPriority(Status status) {
        switch (status) {
        case DONE:
            return PRIORITY_DONE;
        case FLOAT:
            return PRIORITY_FLOAT;
        case PENDING:
            return PRIORITY_PENDING;
        case OVERDUE:
            return PRIORITY_OVERDUE;
        default:
            return PRIORITY_FLOAT;
        }
    }
}
```
###### \java\taskle\model\task\TaskList.java
``` java
    public void refreshInternalList() {
        internalList.sort(new TaskComparator());
    }

```
###### \java\taskle\storage\StorageManager.java
``` java
    @Override
    public void setTaskManagerFilePath(String filePath) {
        assert filePath != null;
        taskManagerStorage = new XmlTaskManagerStorage(filePath);
        raise(new StorageChangedEvent(taskManagerStorage));
    }
}
```
###### \java\taskle\ui\ExistingFileDialog.java
``` java
/**
 * 
 * Confirmation dialog to replace existing file
 *
 */
public class ExistingFileDialog {

    private static final String DIALOG_HEADER = "A Taskle data file currently exists in the specified folder.";
    private static final String DIALOG_CONTENT = "Replace existing file?";
    
    public static void load(NotificationPane notificationPane, Stage stage, File selectedDirectory) throws DataConversionException {
        Alert alert = new Alert(AlertType.CONFIRMATION);
        alert.setHeaderText(DIALOG_HEADER);
        alert.setContentText(DIALOG_CONTENT);
        alert.initOwner(stage);

        Optional<ButtonType> result = alert.showAndWait();
        if (result.get() == ButtonType.OK) {
            StorageUtil.storeConfig(true);
            StorageUtil.updateDirectory(selectedDirectory);
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            
            notificationPane.show("Directory changed to: " + config.getTaskManagerFileDirectory());
        } 
    }
}
```
###### \java\taskle\ui\MainWindow.java
``` java
    /**
     * Change storage file location
     * @throws DataConversionException 
     */
    @FXML
    private void handleChangeDirectory() throws DataConversionException {
        config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
        DirectoryChooser directoryChooser = new DirectoryChooser();
        File selectedDirectory = directoryChooser.showDialog(primaryStage);
        if (selectedDirectory == null) {
        } else if ((selectedDirectory.getAbsolutePath()).equals(config.getTaskManagerFileDirectory())) {
        } else if (new File(selectedDirectory.getAbsolutePath(), config.getTaskManagerFileName()).exists()) {
            ExistingFileDialog.load(notificationPane, primaryStage, selectedDirectory);
        } else {
            StorageUtil.storeConfig(true);
            if (StorageUtil.updateDirectory(selectedDirectory)) {
                config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
                notificationPane.show(String.format(CHANGE_DIRECTORY_SUCCESS, config.getTaskManagerFileDirectory()));
            } else {
                notificationPane.show(CHANGE_DIRECTORY_FAILURE);
            }
        }
    }
    
    /**
     * Change storage file
     * @throws DataConversionException 
     */
    @FXML
    private void handleChangeStorageFile() throws DataConversionException {
        config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
        FileChooser fileChooser = new FileChooser();
        fileChooser.getExtensionFilters().add(
                new ExtensionFilter(FILE_CHOOSER_NAME, FILE_CHOOSER_TYPE));
        File selectedFile = fileChooser.showOpenDialog(primaryStage);
        if (selectedFile != null && !selectedFile.getAbsolutePath().equals(config.getTaskManagerFilePath())) {
            StorageUtil.storeConfig(true);
            if (StorageUtil.updateFile(selectedFile)) {
                notificationPane.show(CHANGE_FILE_SUCCESS);
            } else {
                notificationPane.show(CHANGE_FILE_ERROR);
            }
        }
    }
    
    private void setupNotificationPane() {
        notificationPane = new NotificationPane(rootLayout);
        notificationPane.setId(NOTIFICATION_PANE_ID);
    }

```
###### \java\taskle\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleStorageLocationChangedEvent(StorageChangedEvent slce) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(slce, "Setting last updates status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
        setSaveLocation(slce.getChangedDirectory());
    }
}
```
