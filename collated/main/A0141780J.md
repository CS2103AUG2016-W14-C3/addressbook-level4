# A0141780J
###### \java\taskle\commons\events\model\TaskFilterChangedEvent.java
``` java
/** Indicates the filters in TaskList has changed.
 *  When is showing all, showing pending, done and overdue are all false.
 *  
 */
public class TaskFilterChangedEvent extends BaseEvent {

    public boolean isAllShown;
    public boolean isPendingShown;
    public boolean isDoneShown;
    public boolean isOverdueShown;

    /**
     * Constructs a TaskFilterChangedEvent, given parameters represents
     * the new filters after the change.
     * @param isPendingShown whether to show pending tasks
     * @param isDoneShown whether to show done tasks
     * @param isOverdueShown whether to show overdue tasks
     */
    public TaskFilterChangedEvent(boolean isPendingShown, boolean isDoneShown,
            boolean isOverdueShown){
        if (isPendingShown && isDoneShown && isOverdueShown) {
            isAllShown = true;
            return;
        }
        
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public String toString() {
        String message = StatusFormatUtil.getFormattedFilters(
                isPendingShown, isDoneShown, isOverdueShown);
        return "Filter set to: " + message;
    }
    
    public boolean isPendingShown() {
        return isPendingShown;
    }
    
    public boolean isOverdueShown() {
        return isOverdueShown;
    }
    
    public boolean isDoneShown() {
        return isDoneShown;
    }
    
    public boolean isAllShown() {
        return isAllShown;
    }
}
```
###### \java\taskle\commons\util\DateFormatUtil.java
``` java
    /**
     * Patterns for formatting. One for just the date and another with the time
     */
    private static final String DATE_DISPLAY_PATTERN = "d MMM yyyy";
    private static final String TIME_DISPLAY_PATTERN = "h:mma";
    private static final String DATE_TIME_DISPLAY_PATTERN = "d MMM yyyy, h:mma";
    private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(DATE_DISPLAY_PATTERN);
    private static final SimpleDateFormat SIMPLE_TIME_FORMAT = new SimpleDateFormat(TIME_DISPLAY_PATTERN);
    private static final SimpleDateFormat SIMPLE_DATE_TIME_FORMAT = new SimpleDateFormat(DATE_TIME_DISPLAY_PATTERN);

    private static final String EVENT_DATES_DELIMITER = " to ";

    private static final Calendar calendar = Calendar.getInstance();

    /** Private constructor to prevent instantiation. */
    private DateFormatUtil() {
    }

    /**
     * Formats given start and end dates according to their respective time and
     * dates in our desired format.
     * 
     * @param startDate start date object
     * @param endDate end date object
     * @return formatted string for date time for display to user
     */
    public static String formatEventDates(Date startDate, Date endDate) {
        if (startDate == null || endDate == null) {
            return "";
        }

        calendar.setTime(startDate);
        int startDay = calendar.get(Calendar.DAY_OF_YEAR);
        int startYear = calendar.get(Calendar.YEAR);

        calendar.setTime(endDate);
        int endDay = calendar.get(Calendar.DAY_OF_YEAR);
        int endYear = calendar.get(Calendar.YEAR);

        if (startDate.equals(endDate)) {
            return formatSingleDate(endDate);
        } else if (startDay == endDay && startYear == endYear) {
            return formatSameDayEventDates(startDate, endDate);
        } else {
            return formatTwoDaysEventDates(startDate, endDate);
        }
    }
    
    /**
     * Formats the date as a String such that time is not shown if its 
     * 23:59:99.
     * Date is also displayed in format as designed in UI.
     * 
     * @param date Given date object to format
     * @return formatted date time string for display to user
     */
    public static String formatSingleDate(Date date) {
        if (date == null) {
            return "";
        }

        calendar.setTime(date);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int min = calendar.get(Calendar.MINUTE);
        int sec = calendar.get(Calendar.SECOND);
        int msec = calendar.get(Calendar.MILLISECOND);
        if (hour == 23 && min == 59 && sec == 59) {
            return SIMPLE_DATE_FORMAT.format(date);
        } else {
            return SIMPLE_DATE_TIME_FORMAT.format(date);
        }
    }
    
    private static String formatSameDayEventDates(Date startDate, Date endDate) {
        return formatSingleDate(startDate) 
               + EVENT_DATES_DELIMITER
               + SIMPLE_TIME_FORMAT.format(endDate);
    }
    
    private static String formatTwoDaysEventDates(Date startDate, Date endDate) {
        return formatSingleDate(startDate) + EVENT_DATES_DELIMITER 
               + formatSingleDate(endDate);
    }

```
###### \java\taskle\commons\util\DateFormatUtil.java
``` java
    /**
     * Used for converting a given array of dates into an add command friendly
     * format.
     * 
     * @param dates dates to be added to this formatted String
     * @return command ready format for the dates
     */
    public static String getDateArgString(Date... dates) {
        String[] dateStrings = new String[dates.length];
        for (int i = 0; i < dates.length; i++) {
            dateStrings[i] = SIMPLE_DATE_TIME_FORMAT.format(dates[i]);
        }
        
        return String.join(EVENT_DATES_DELIMITER, dateStrings);
    }
}
```
###### \java\taskle\commons\util\StatusFormatUtil.java
``` java
    /**
     * Returns a formatted string for filters as specified.
     * 
     * @param showPending whether to show or filter pending
     * @param showDone whether to show or filter done
     * @param showOverdue whether to show or filter overdue
     * @return a formatted String, filters are delimited by commas
     */
    public static String getFormattedFilters(
            boolean showPending, boolean showDone, boolean showOverdue) {
        String[] messageArray = new String[] {
                "Not Pending", "Not Done", "Not Overdue"
        };
        
        if (showPending) {
            messageArray[0] = "Pending";
        }
        
        if (showDone) {
            messageArray[1] = "Done";
        }
        
        if (showOverdue) {
            messageArray[2] = "Overdue";
        }
        
        String message = String.join(", ", messageArray);
        
        return message;
    }
    
}
```
###### \java\taskle\logic\commands\AddCommand.java
``` java

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_WORD_SHORT = "a";

    public static final String MESSAGE_USAGE = "\n" + COMMAND_WORD + ": Adds a task / event into Taskle (with its respective deadline or end-date.)\n"
            + "\nFormat: add task_name by [date + time] [remind date + time]\n"
            + "or\nadd task_name from [date + time] to [date + time] [remind date + time]\n"
            + "\nExample: " + "add Business Trip from 4 Oct to 5 Oct remind 3 Oct 2pm";

    public static final String MESSAGE_SUCCESS = "Added New Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Taskle!";

    private final Task toAdd;

    /**
     * Convenience constructor using raw name value.
     * 
     * @param name Name of  task to be added
     */
    public AddCommand(String name) {
        assert (name != null);
        this.toAdd = new FloatTask(new Name(name));
    }
    
    /**
     * Convenience constructor using raw name value.
     * 
     * @param nameString name of task in string format
     * @param startDate start date of task
     * @param endDate end date of task
     * @param remindDate reminder date of task
     */
    public AddCommand(String nameString, Date startDate, 
                      Date endDate, Date remindDate) {
        assert (nameString != null);
        Name name = new Name(nameString);
        if (startDate != null && endDate != null) {
            toAdd = new EventTask(name, startDate, endDate);
        } else if (endDate != null) {
            toAdd = new DeadlineTask(name, endDate);
        } else {
            toAdd = new FloatTask(name);
        }
        
        if (remindDate != null) {
            toAdd.setRemindDate(remindDate);
        }
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;        
        model.storeTaskManager(COMMAND_WORD);
        model.addTask(toAdd);
        
        // Display reminder message only when reminder is set
        if (toAdd.getRemindDate() == null) {
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd), true);
        } else {
            return new CommandResult(
                    String.format(MESSAGE_SUCCESS, toAdd 
                    + " Reminder on: " + toAdd.getRemindDetailsString()), true);
        }
    }

}

```
###### \java\taskle\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any 
 * of the argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {
    
    public static final String COMMAND_WORD = "find";
    public static final String COMMAND_WORD_SHORT ="f";

    public static final String MESSAGE_USAGE = "\n" 
            + COMMAND_WORD + ": Finds all tasks in Taskle that both contain the keywords and fulfill the specific status."
            + "\n\nFormat: " + COMMAND_WORD + " keywords [-status]\n"
            + "\nExample: " + COMMAND_WORD + " books";

    private final Set<String> keywords;
    
    // Fields for whether to show the corresponding statuses
    private boolean isPendingShown = true;
    private boolean isDoneShown = false;
    private boolean isOverdueShown = true;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }
    
    public FindCommand(Set<String> keywords, boolean isPendingShown, 
                       boolean isDoneShown, boolean isOverdueShown) {
        this.keywords = keywords;
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public CommandResult execute() {
        model.updateFilters(keywords, isPendingShown, isDoneShown, isOverdueShown);
        return new CommandResult(
                getMessageForTaskListShownSummary(
                        model.getFilteredTaskList().size()),
                true);
    }
    
}
```
###### \java\taskle\logic\commands\ListCommand.java
``` java
/**
 * Lists all tasks in the Task Manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_WORD_SHORT = "l";

    public static final String MESSAGE_LIST_SUCCESS = 
            "Listed %1$s tasks";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Lists all tasks with the specified statuses\n"
            + "\nFormat: " + COMMAND_WORD + " [-status]\n"
            + "Note: You can have more than 1 statuses or none at all\n"
            + "If no status is specified, pending and overdue items will be listed\n"
            + "\nExample: " + COMMAND_WORD + " -done -pending";
    
    // Fields for whether to show the corresponding statuses
    private final boolean isPendingShown;
    private final boolean isDoneShown;
    private final boolean isOverdueShown;

    public ListCommand(boolean isPendingShown, boolean isDoneShown, 
                       boolean isOverdueShown) {
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public CommandResult execute() {
        model.updateFilters(isPendingShown, isDoneShown, isOverdueShown);
        String message = StatusFormatUtil.getFormattedFilters(
                isPendingShown, isDoneShown, isOverdueShown);
        return new CommandResult(String.format(MESSAGE_LIST_SUCCESS, message), 
                                 true);
    }

}
```
###### \java\taskle\logic\parser\AddCommandParser.java
``` java
    /**
     * Generates a deadline add command with reminder date
     * 
     * @param nameString name to be used for deadline add command
     * @param dates List of dates to be used to generate deadline. Should be 1.
     * @param remindDate reminder date. Nullable.
     * @return a valid deadline add command with reminder date
     */
    private AddCommand generateDeadlineAddCommand(
            String nameString, List<Date> dates, Date remindDate) {
        assert dates.size() == 1;
        return new AddCommand(nameString, null, dates.get(0), remindDate);
    }

    /**
     * Generates a event add command with reminder date
     * 
     * @param fullArgs full argument string
     * @param name name to be used for deadline add command
     * @param dates List of dates to be used to generate deadline. Should be 1.
     * @param remindDate List of dates to be used for reminder date. Should be 1.
     * @return a valid event add command with reminder date
     */
    private AddCommand generateEventAddCommand(
            String name, List<Date> dates, Date remindDate) {
        assert dates.size() == 1 || dates.size() == 2;

        // There are either 2 or 1 dates given, generate accordingly
        if (dates.size() == 2) {
            return new AddCommand(name, dates.get(0), dates.get(1), remindDate);
        } else {
            return new AddCommand(name, dates.get(0), dates.get(0), remindDate);
        }
    }

}
```
###### \java\taskle\model\help\CommandGuide.java
``` java
/**
 * Model class to encapsulate the information provided
 * by each row in the help window. *
 */
public class CommandGuide {
    
    // Member variables for a CommandGuide object
    private String actionName;
    private String commandWord;
    private String shortcutCommand;
    private String[] args; 
    
    /**
     * Constructor for CommandGuide
     * Asserts that name and commandWord are non-null because it is
     * constructed by custom parameters in HelpWindow always.
     * 
     * @param name Name of the action and command
     * @param commandWord command keyword
     * @param args optional arguments for command keyword
     */
    public CommandGuide(String name, String shortCommand, String commandWord, String... args) {
        assert name != null;
        assert commandWord != null;
        this.actionName = name;
        this.commandWord = commandWord;
        this.shortcutCommand = shortCommand;
        this.args = args;
    }
    
    public String getName() {
        return actionName;
    }
    
    public String getCommandWord() {
        return commandWord;
    }
    
    public String getShortcutCommand() {
        return shortcutCommand;
    }
    public String[] getArgs() {
        return args;
    }
}
```
###### \java\taskle\model\Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();
    
    /** Updates the filter of the filtered task list to show tasks filtered by predicates*/
    void updateFilteredListWithStatuses();
    
    /** Updates the filter status predicates*/
    void updateFilters(boolean pending, boolean done, boolean overdue);

    /** Updates the filter keywords predicates*/
    void updateFilters(Set<String> keywords);
    
    /** Updates the filter statuses and keywords predicates*/
    void updateFilters(Set<String>keywords, boolean pending, 
                       boolean done, boolean overdue);

}
```
###### \java\taskle\model\ModelManager.java
``` java
    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }
    
    @Override
    public void updateFilteredListWithStatuses() {
        filteredTasks.setPredicate(getStatusPredicate());
    }
    
    @Override
    public void updateFilters(Set<String> keywords){
        updateFilteredListFindKeywords(keywords);
    }
    
    @Override
    public void updateFilters(Set<String> keywords, boolean isPendingShown, 
                              boolean isDoneShown, boolean isOverdueShown){
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
        raise(new TaskFilterChangedEvent(isPendingShown, isDoneShown, isOverdueShown));
        updateFilteredListFindKeywords(keywords);
    }
    
    @Override
    public void updateFilters(
            boolean isPendingShown, boolean isDoneShown, boolean isOverdueShown) {
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
        raise(new TaskFilterChangedEvent(isPendingShown, isDoneShown, isOverdueShown));
        updateFilteredListWithStatuses();
    }
    
    private void updateFilteredListFindKeywords(Set<String> keywords) {
        Expression keywordExpression = new PredicateExpression(new NameQualifier(keywords));
        Predicate<Task> statusPred = getStatusPredicate();
        Predicate<Task> combinedPred = statusPred.and(keywordExpression::satisfies);
        filteredTasks.setPredicate(combinedPred);
    }
    
    /**
     * Returns the predicate to use for filtering as specified by 
     * the show status boolean fields.
     * @return
     */
    private Predicate<Task> getStatusPredicate() {
        Predicate<Task> basePred = t -> false;
        Predicate<Task> pendingPred = t -> t.getStatus() == Status.PENDING
                || t.getStatus() == Status.FLOAT;
        Predicate<Task> donePred = t -> t.getStatus() == Status.DONE;
        Predicate<Task> overduePred = t -> t.getStatus() == Status.OVERDUE;
        
        if (isPendingShown) {
            basePred = basePred.or(pendingPred);
        }
        
        if (isDoneShown) {
            basePred = basePred.or(donePred);
        }
        
        if (isOverdueShown) {
            basePred = basePred.or(overduePred);
        }
        
        return basePred;
    }
```
###### \java\taskle\ui\CommandBox.java
``` java
    public void configure(NotificationPane notificationPane, 
                          Logic logic) {
        this.notificationPane = notificationPane;
        this.logic = logic;
        createPopOver();
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }
    
    /** Creates a pop over with content layout and style specified. */
    private void createPopOver() {
        popOver = new PopOver();
        popOver.setId(POP_OVER_ID);
        setPopOverLayout();
        setPopOverStyle();
    }
    
    /** Sets up the layout inside popover. */
    private void setPopOverLayout() {
        popOverText = new Text();
        popOverText.setId(POP_OVER_TEXT_ID);
        
        VBox vBox = new VBox();
        vBox.getChildren().add(popOverText);
        vBox.setPadding(new Insets(10));
        popOver.setContentNode(vBox);
    }
    
    /** Sets up the style for popover and how it is displayed. */
    private void setPopOverStyle() {
        popOver.setArrowLocation(ArrowLocation.BOTTOM_CENTER);
        popOver.setFadeInDuration(new Duration(300));
        popOver.setDetachable(false);
        popOver.setAutoHide(true);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Java FXML method that is called everytime there's a 
     * new command input.
     */
    @FXML
    private void handleCommandInputChanged() {
        //Take a copy of the command text
        previousCommandText = commandTextField.getText();
        
        // execute command and display command feedback
        mostRecentResult = logic.execute(previousCommandText);
        displayCommandFeedback(mostRecentResult);
        logger.info("Result: " + mostRecentResult.getFeedback());
    }
    
    /**
     * Displays command feedback based on results.
     * If result is not successful, no feedback is displayed.
     * If successful, feedback is displayed.
     * 
     * @param commandResult Command result to use for display.
     */
    private void displayCommandFeedback(CommandResult commandResult) {
        assert commandResult != null;
        
        String feedback = commandResult.getFeedback();
        if (!commandResult.isSuccessful()) {
            return;
        }
        
        showCorrectCommand(feedback);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandText));
        showIncorrectCommand(event.getFeedback());
        restoreCommandText();
    }

    /**
     * Shows the UI elements for incorrect command.
     * 
     * @param feedback feedback message to user to incorrect command.
     */
    private void showIncorrectCommand(String feedback) {
        popOverText.setText(feedback);
        popOver.show(commandTextField);
        notificationPane.hide();
    }
    
    /**
     * Shows the UI elements for correct command.
     * 
     * @param feedback feedback message to user for correct command.
     */
    private void showCorrectCommand(String feedback) {
        popOver.hide();
        commandTextField.clear();
        notificationPane.show(feedback);
    }
    
    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandText);
        commandTextField.positionCaret(previousCommandText.length());
    }

}
```
###### \java\taskle\ui\StatusDisplayPanel.java
``` java
/**
 * A ui for the status display panel that is displayed on top of the command box
 * in the application.
 */
public class StatusDisplayPanel extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(StatusDisplayPanel.class);

    private HBox mainPane;

    @FXML
    private Label displayLabel;
        
    @FXML
    private ImageView allChip;
    
    @FXML
    private ImageView pendingChip;

    @FXML
    private ImageView overdueChip;
    
    @FXML
    private ImageView doneChip;

    private AnchorPane placeHolder;

    private static final String FXML = "StatusDisplayPanel.fxml";

    public static StatusDisplayPanel load(Stage stage, AnchorPane placeHolder) {
        StatusDisplayPanel statusDisplayPanel = UiPartLoader.loadUiPart(stage, placeHolder, new StatusDisplayPanel());
        statusDisplayPanel.configure();
        return statusDisplayPanel;
    }

    public void configure() {
        addMainPane();
        setupInitialChips();
        registerAsAnEventHandler(this);
    }

    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (HBox) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    /**
     * Prepares the initial chips, namely the pending and overdue chips and
     * the display label.
     */
    private void setupInitialChips() {
        ObservableList<Node> nodes = mainPane.getChildren();
        nodes.clear();
        nodes.add(displayLabel);
        nodes.add(pendingChip);
        nodes.add(overdueChip);
    }

    @Subscribe
    private void handleTaskFilterChangedEvent(TaskFilterChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        ObservableList<Node> nodes = mainPane.getChildren();
        nodes.clear();
        nodes.add(displayLabel);
        updateNodes(nodes, event);
    }
    
    /**
     * Updates the nodes to reflect the TaskFilterChangedEvent.
     * 
     * @param nodes List of nodes used.
     * @param event Event that reflects the new filters.
     */
    private void updateNodes(
            ObservableList<Node> nodes, TaskFilterChangedEvent event) {
        if (event.isAllShown) {
            nodes.add(allChip);
            return;
        }
        
        updatePendingNode(nodes, event);
        updateDoneNode(nodes, event);
        updateOverdueNode(nodes, event);
    }
    
    private void updatePendingNode(ObservableList<Node> nodes, 
                                   TaskFilterChangedEvent event) {
        if (event.isPendingShown) {
            nodes.add(pendingChip);
        }
    }
    
    private void updateDoneNode(ObservableList<Node> nodes, 
                                TaskFilterChangedEvent event) {
        if (event.isDoneShown) {
            nodes.add(doneChip);
        } 
    }
    
    private void updateOverdueNode(ObservableList<Node> nodes, 
                                   TaskFilterChangedEvent event) {
        if (event.isOverdueShown) {
            nodes.add(overdueChip);
        }
    }
    
    
    
}
```
###### \resources\view\DarkTheme.css
``` css
.background {
    -fx-background-color: #37474F;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Calibri";
    -fx-text-fill: white;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-status-display {
    -fx-font-size: 14pt;
    -fx-font-family: "Roboto Condensed";
	-fx-font-weight: Bold;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.table-view {
    -fx-base: #37474F;
    -fx-control-inner-background: #37474F;
    -fx-background-color: #37474F;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-width: 0 0 1 0;
    -fx-background-color: transparent;
    -fx-border-color:
        transparent
        transparent
        derive(-fx-base, 80%)
        transparent;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 20pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-alignment: center-left;
    -fx-opacity: 1;
}

.table-view:focused .table-row-cell:filled:focused:selected {
    -fx-background-color: -fx-focus-color;
}

.split-pane:horizontal .split-pane-divider {
    -fx-border-color: #37474F;
    -fx-background-color: transparent, #37474F;
}

.split-pane {
    -fx-background-color: #37474F;
}

.list-cell {
	-fx-background-color: #37474F;
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 2 0 2 0;
}

.list-cell .label {
    -fx-text-fill: white;
}

.cell_big_label {
    -fx-font-size: 20px;
    -fx-text-fill: white;
}

.header_label {
    -fx-font-size: 20px;
    -fx-text-fill: white;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: white;
}

.anchor-pane {
     -fx-background-color: #37474F;
}

.anchor-pane-with-border {
     -fx-background-color: #37474F;
     -fx-border-color: #37474F;
}

.status-bar {
    -fx-background-color: #37474F;
    -fx-text-fill: black;
}

.result-display {
    -fx-background-color: #37474F;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: #37474F;
    -fx-border-width: 1px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.status-display-pane {
    -fx-background-color: #37474F;
}

.grid-pane {
    -fx-background-color: #37474F;
    -fx-border-color: #37474F;
    -fx-border-width: 1px;
}

.header-grid-pane {
    -fx-background-color: #37474F;
    -fx-border-color: #37474F;
}

.grid-pane .anchor-pane {
    -fx-background-color: #37474F;
}

.context-menu {
    -fx-background-color: #37474F
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color: #37474F
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: #37474F;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #37474F;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #37474F;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: #37474F;
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .thumb {
    -fx-background-color: derive(#1d1d1d, 50%);
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-color:#37474F;
    -fx-border-width: 1 1 1 1;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #taskListPanel {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}
```
###### \resources\view\HelpWindow.fxml
``` fxml
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.TableView?>
<?import java.net.URL?>
<AnchorPane fx:id="helpWindowRoot" maxHeight="Infinity"
	maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity"
	stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.HelpWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<TableView fx:id="helpTable" minHeight="650" minWidth="880"
			AnchorPane.topAnchor="0.0" AnchorPane.bottomAnchor="0.0"
			AnchorPane.rightAnchor="0.0" AnchorPane.leftAnchor="0.0">
		</TableView>
	</children>
</AnchorPane>
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.MainWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<MenuBar VBox.vgrow="NEVER">
			<menus>
				<Menu mnemonicParsing="false" text="File">
					<items>
						<MenuItem mnemonicParsing="false" onAction="#handleChangeStorageFile" text="Open File" />
						<MenuItem mnemonicParsing="false" onAction="#handleChangeDirectory" text="Change Directory" />
						<MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
					</items>
				</Menu>
				<Menu mnemonicParsing="false" text="Help">
					<items>
						<MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
					</items>
				</Menu>
			</menus>
		</MenuBar>
		<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
		<AnchorPane fx:id="statusDisplayPanelPlaceholder" maxHeight="60.0" minHeight="60.0" prefHeight="60.0" VBox.vgrow="NEVER" />
		<AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER" />
		<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
	</children>
</VBox>
```
###### \resources\view\StatusDisplayPanel.fxml
``` fxml
<HBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="60.0" minWidth="-Infinity" prefHeight="60.0" prefWidth="720.0" styleClass="status-display-pane" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.StatusDisplayPanel">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
      <Label fx:id="displayLabel" styleClass="label-status-display" text="Currently showing:">
         <padding>
            <Insets bottom="16.0" left="16.0" right="16.0" top="16.0" />
         </padding>
      </Label>
		
		<ImageView fx:id="allChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/all_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="overdueChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/overdue_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="pendingChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/pending_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="doneChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/done_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
	</children>
</HBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.shape.Rectangle?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
	<children>

		<GridPane HBox.hgrow="ALWAYS">
			<columnConstraints>
            <ColumnConstraints hgrow="NEVER" maxWidth="80.0" minWidth="12.0" prefWidth="16.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="148.0" minWidth="30.0" prefWidth="70.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="450.0" minWidth="441.0" prefWidth="441.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="377.0" minWidth="10.0" prefWidth="362.0" />
            <ColumnConstraints maxWidth="495.0" minWidth="432.0" prefWidth="447.0" />
			</columnConstraints>
			<rowConstraints>
				<RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="ALWAYS" />
			</rowConstraints>
			<children>
				<Label fx:id="id" styleClass="cell_big_label" text="\$id" GridPane.columnIndex="1">
               <GridPane.margin>
                  <Insets left="10.0" />
               </GridPane.margin></Label>
				<Label fx:id="name" minWidth="-Infinity" prefWidth="450.0" styleClass="cell_big_label" text="\$name" GridPane.columnIndex="2" />
				<Label fx:id="reminderDate" minWidth="-Infinity" prefHeight="21.0" prefWidth="359.0" styleClass="cell_big_label" text="\$reminderDate" textAlignment="RIGHT" GridPane.columnIndex="3" GridPane.halignment="RIGHT" />
					
				<Label fx:id="details" minWidth="-Infinity" prefHeight="21.0" prefWidth="445.0" styleClass="cell_big_label" text="\$details" GridPane.columnIndex="4" GridPane.halignment="RIGHT" />
            <Rectangle fx:id="colorTag" arcHeight="5.0" arcWidth="5.0" fill="DODGERBLUE" height="50.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" width="15.0" GridPane.vgrow="ALWAYS" />
			</children>
		</GridPane>
	</children>
	<padding>
		<Insets bottom="10.0" right="10.0" top="10.0" />
	</padding>
</HBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
	AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"
	xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="taskle.ui.TaskListPanel" stylesheets="@DarkTheme.css">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<GridPane styleClass="header-grid-pane" HBox.hgrow="ALWAYS">
			<columnConstraints>
				<ColumnConstraints hgrow="NEVER" maxWidth="16.0"
					minWidth="16.0" prefWidth="16.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="72.0"
					minWidth="72.0" prefWidth="72.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="450.0"
					minWidth="450.0" prefWidth="450.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="360.0"
					minWidth="360.0" prefWidth="360.0" />
				<ColumnConstraints maxWidth="359.0" minWidth="359.0"
					prefWidth="359.0" />
			</columnConstraints>
			<rowConstraints>
				<RowConstraints minHeight="10.0" prefHeight="30.0"
					vgrow="ALWAYS" />
			</rowConstraints>
			<children>
				<Label styleClass="header_label" text="ID"
					GridPane.columnIndex="1" GridPane.halignment="LEFT">
					<GridPane.margin>
						<Insets left="10.0" />
					</GridPane.margin>
				</Label>
				<Label maxWidth="400.0" minWidth="368.0" prefHeight="23.0"
					prefWidth="403.0" styleClass="header_label" text="Name"
					GridPane.columnIndex="2" />
				<Label minWidth="-Infinity" prefHeight="21.0" prefWidth="356.0"
					styleClass="header_label" text="Reminder" GridPane.columnIndex="3"
					GridPane.halignment="LEFT" />

				<Label minWidth="-Infinity" prefWidth="500.0" styleClass="header_label"
					text="Dates" GridPane.columnIndex="4" GridPane.halignment="LEFT" />
			</children>
		</GridPane>

		<ListView fx:id="taskListView" styleClass="anchor-pane"
			VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
