# A0141780J
###### \java\taskle\commons\events\model\TaskFilterChangedEvent.java
``` java
/** Indicates the filters in TaskList has changed.
 *  When is showing all, showing pending, done and overdue are all false.
 *  
 */
public class TaskFilterChangedEvent extends BaseEvent {

    public boolean isAllShown;
    public boolean isPendingShown;
    public boolean isDoneShown;
    public boolean isOverdueShown;

    /**
     * Constructs a TaskFilterChangedEvent, given parameters represents
     * the new filters after the change.
     * @param isPendingShown whether to show pending tasks
     * @param isDoneShown whether to show done tasks
     * @param isOverdueShown whether to show overdue tasks
     */
    public TaskFilterChangedEvent(boolean isPendingShown, boolean isDoneShown,
            boolean isOverdueShown){
        if (isPendingShown && isDoneShown && isOverdueShown) {
            isAllShown = true;
            return;
        }
        
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public String toString() {
        String message = StatusFormatUtil.getFormattedFilters(
                isPendingShown, isDoneShown, isOverdueShown);
        return "Filter set to: " + message;
    }
    
    public boolean isPendingShown() {
        return isPendingShown;
    }
    
    public boolean isOverdueShown() {
        return isOverdueShown;
    }
    
    public boolean isDoneShown() {
        return isDoneShown;
    }
    
    public boolean isAllShown() {
        return isAllShown;
    }
}
```
###### \java\taskle\commons\util\DateFormatUtil.java
``` java
    /**
     * Patterns for formatting. One for just the date and another with the time
     */
    private static final String DATE_DISPLAY_PATTERN = "d MMM yyyy";
    private static final String TIME_DISPLAY_PATTERN = "h:mma";
    private static final String DATE_TIME_DISPLAY_PATTERN = "d MMM yyyy, h:mma";
    private static final SimpleDateFormat SIMPLE_DATE_FORMAT = new SimpleDateFormat(DATE_DISPLAY_PATTERN);
    private static final SimpleDateFormat SIMPLE_TIME_FORMAT = new SimpleDateFormat(TIME_DISPLAY_PATTERN);
    private static final SimpleDateFormat SIMPLE_DATE_TIME_FORMAT = new SimpleDateFormat(DATE_TIME_DISPLAY_PATTERN);

    private static final String EVENT_DATES_DELIMITER = " to ";

    private static final Calendar calendar = Calendar.getInstance();

    /** Private constructor to prevent instantiation. */
    private DateFormatUtil() {
    }

    /**
     * Formats given start and end dates according to their respective time and
     * dates in our desired format.
     * 
     * @param startDate start date object
     * @param endDate end date object
     * @return formatted string for date time for display to user
     */
    public static String formatEventDates(Date startDate, Date endDate) {
        if (startDate == null || endDate == null) {
            return "";
        }

        calendar.setTime(startDate);
        int startDay = calendar.get(Calendar.DAY_OF_YEAR);
        int startYear = calendar.get(Calendar.YEAR);

        calendar.setTime(endDate);
        int endDay = calendar.get(Calendar.DAY_OF_YEAR);
        int endYear = calendar.get(Calendar.YEAR);

        if (startDate.equals(endDate)) {
            return formatSingleDate(endDate);
        } else if (startDay == endDay && startYear == endYear) {
            return formatSameDayEventDates(startDate, endDate);
        } else {
            return formatTwoDaysEventDates(startDate, endDate);
        }
    }
    
    /**
     * Formats the date as a String such that time is not shown if its 
     * 23:59:99.
     * Date is also displayed in format as designed in UI.
     * 
     * @param date Given date object to format
     * @return formatted date time string for display to user
     */
    public static String formatSingleDate(Date date) {
        if (date == null) {
            return "";
        }

        calendar.setTime(date);
        int hour = calendar.get(Calendar.HOUR_OF_DAY);
        int min = calendar.get(Calendar.MINUTE);
        int sec = calendar.get(Calendar.SECOND);
        int msec = calendar.get(Calendar.MILLISECOND);
        if (hour == 23 && min == 59 && sec == 59) {
            return SIMPLE_DATE_FORMAT.format(date);
        } else {
            return SIMPLE_DATE_TIME_FORMAT.format(date);
        }
    }
    
    private static String formatSameDayEventDates(Date startDate, Date endDate) {
        return formatSingleDate(startDate) 
               + EVENT_DATES_DELIMITER
               + SIMPLE_TIME_FORMAT.format(endDate);
    }
    
    private static String formatTwoDaysEventDates(Date startDate, Date endDate) {
        return formatSingleDate(startDate) + EVENT_DATES_DELIMITER 
               + formatSingleDate(endDate);
    }

```
###### \java\taskle\commons\util\DateFormatUtil.java
``` java
    /**
     * Used for converting a given array of dates into an add command friendly
     * format.
     * 
     * @param dates dates to be added to this formatted String
     * @return command ready format for the dates
     */
    public static String getDateArgString(Date... dates) {
        String[] dateStrings = new String[dates.length];
        for (int i = 0; i < dates.length; i++) {
            dateStrings[i] = SIMPLE_DATE_TIME_FORMAT.format(dates[i]);
        }
        
        return String.join(EVENT_DATES_DELIMITER, dateStrings);
    }
}
```
###### \java\taskle\commons\util\StatusFormatUtil.java
``` java
    /**
     * Returns a formatted string for filters as specified.
     * 
     * @param showPending whether to show or filter pending
     * @param showDone whether to show or filter done
     * @param showOverdue whether to show or filter overdue
     * @return a formatted String, filters are delimited by commas
     */
    public static String getFormattedFilters(
            boolean showPending, boolean showDone, boolean showOverdue) {
        String[] messageArray = new String[] {
                "Not Pending", "Not Done", "Not Overdue"
        };
        
        if (showPending) {
            messageArray[0] = "Pending";
        }
        
        if (showDone) {
            messageArray[1] = "Done";
        }
        
        if (showOverdue) {
            messageArray[2] = "Overdue";
        }
        
        String message = String.join(", ", messageArray);
        
        return message;
    }
    
}
```
###### \java\taskle\logic\commands\AddCommand.java
``` java

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_WORD_SHORT = "a";

    public static final String MESSAGE_USAGE = "\n" + COMMAND_WORD + ": Adds a task / event into Taskle (with its respective deadline or end-date.)\n"
            + "\nFormat: add task_name by [date + time] [remind date + time]\n"
            + "or\nadd task_name from [date + time] to [date + time] [remind date + time]\n"
            + "\nExample: " + "add Business Trip from 4 Oct to 5 Oct remind 3 Oct 2pm";

    public static final String MESSAGE_SUCCESS = "Added New Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in Taskle!";

    private final Task toAdd;

    /**
     * Convenience constructor using raw name value.
     * 
     * @param name Name of  task to be added
     */
    public AddCommand(String name) {
        assert (name != null);
        this.toAdd = new FloatTask(new Name(name));
    }
    
    /**
     * Convenience constructor using raw name value.
     * 
     * @param nameString name of task in string format
     * @param startDate start date of task
     * @param endDate end date of task
     * @param remindDate reminder date of task
     */
    public AddCommand(String nameString, Date startDate, 
                      Date endDate, Date remindDate) {
        assert (nameString != null);
        Name name = new Name(nameString);
        if (startDate != null && endDate != null) {
            toAdd = new EventTask(name, startDate, endDate);
        } else if (endDate != null) {
            toAdd = new DeadlineTask(name, endDate);
        } else {
            toAdd = new FloatTask(name);
        }
        
        if (remindDate != null) {
            toAdd.setRemindDate(remindDate);
        }
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;        
        model.storeTaskManager(COMMAND_WORD);
        model.addTask(toAdd);
        
        // Display reminder message only when reminder is set
        if (toAdd.getRemindDate() == null) {
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd), true);
        } else {
            return new CommandResult(
                    String.format(MESSAGE_SUCCESS, toAdd 
                    + " Reminder on: " + toAdd.getRemindDetailsString()), true);
        }
    }

}

```
###### \java\taskle\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any 
 * of the argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {
    
    public static final String COMMAND_WORD = "find";
    public static final String COMMAND_WORD_SHORT ="f";

    public static final String MESSAGE_USAGE = "\n" 
            + COMMAND_WORD + ": Finds all tasks in Taskle that both contain the keywords and fulfill the specific status."
            + "\n\nFormat: " + COMMAND_WORD + " keywords [-status]\n"
            + "\nExample: " + COMMAND_WORD + " books";

    private final Set<String> keywords;
    
    // Fields for whether to show the corresponding statuses
    private boolean isPendingShown = true;
    private boolean isDoneShown = false;
    private boolean isOverdueShown = true;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }
    
    public FindCommand(Set<String> keywords, boolean isPendingShown, 
                       boolean isDoneShown, boolean isOverdueShown) {
        this.keywords = keywords;
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public CommandResult execute() {
        model.updateFilters(keywords, isPendingShown, isDoneShown, isOverdueShown);
        return new CommandResult(
                getMessageForTaskListShownSummary(
                        model.getFilteredTaskList().size()),
                true);
    }
    
}
```
###### \java\taskle\logic\commands\ListCommand.java
``` java
/**
 * Lists all tasks in the Task Manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_WORD_SHORT = "l";

    public static final String MESSAGE_LIST_SUCCESS = 
            "Listed %1$s tasks";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Lists all tasks with the specified statuses\n"
            + "\nFormat: " + COMMAND_WORD + " [-status]\n"
            + "Note: You can have more than 1 statuses or none at all\n"
            + "If no status is specified, pending and overdue items will be listed\n"
            + "\nExample: " + COMMAND_WORD + " -done -pending";
    
    // Fields for whether to show the corresponding statuses
    private final boolean isPendingShown;
    private final boolean isDoneShown;
    private final boolean isOverdueShown;

    public ListCommand(boolean isPendingShown, boolean isDoneShown, 
                       boolean isOverdueShown) {
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
    }

    @Override
    public CommandResult execute() {
        model.updateFilters(isPendingShown, isDoneShown, isOverdueShown);
        String message = StatusFormatUtil.getFormattedFilters(
                isPendingShown, isDoneShown, isOverdueShown);
        return new CommandResult(String.format(MESSAGE_LIST_SUCCESS, message), 
                                 true);
    }

}
```
###### \java\taskle\logic\parser\AddCommandParser.java
``` java
/**
 * AddCommandParser class to handle parsing of add commands.
 */
public class AddCommandParser extends CommandParser {

    private static final String ADD_ARGS_NAME_GROUP = "name";
    private static final String ADD_ARGS_DATE_DEADLINE_GROUP = "dateDeadline";
    private static final String ADD_ARGS_DATE_EVENT_GROUP = "dateEvent";
    private static final String ADD_ARGS_DATE_REMINDER_GROUP = "dateRemind";

    public AddCommandParser() {
    }
    
    /**
     * Regex pattern that groups into name (all words until last by|from),
     * dateFrom (all words after from containing from at the start) or dateBy
     * (all words after by containing by at the start). The reminder date is
     * also captured in dateRemind.
     */
    private static final Pattern ADD_ARGS_FORMAT = Pattern.compile(
            "(?<name>(?:.+\\s(?=by|from))|.+?(?=remind)|.+$|)" 
            + "(?<dateEvent>(?=from)(?:.+\\s(?=remind)|.+$))*"
            + "(?<dateDeadline>(?=by)(?:.+\\s(?=remind)|.+$))*" 
            + "(?<dateRemind>(?=remind).*)*");

    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(AddCommand.COMMAND_WORD) 
               || commandWord.equals(AddCommand.COMMAND_WORD_SHORT);
    }

    @Override
    public Command parseCommand(String args) {
        return prepareAdd(args);
    }

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        final Matcher matcher = ADD_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        // Get respective name, date Strings and reminder date
        String nameString = matcher.group(ADD_ARGS_NAME_GROUP).trim();
        String eventDatesString = matcher.group(ADD_ARGS_DATE_EVENT_GROUP);
        String deadlineString = matcher.group(ADD_ARGS_DATE_DEADLINE_GROUP);

        // Check if name argument exists
        if (nameString == null || nameString.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  AddCommand.MESSAGE_USAGE));
        }
        
        // Check if reminder argument is valid
        String remindDateString = matcher.group(ADD_ARGS_DATE_REMINDER_GROUP);
        Date remindDate = DateParser.parseRemindDate(remindDateString);
        // If reminder is stated but has no date
        if (remindDateString != null && !remindDateString.isEmpty()
            && (eventDatesString != null || deadlineString != null) 
            && remindDate == null) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  AddCommand.MESSAGE_USAGE));
        }

        return getCorrectCommand(args, nameString, eventDatesString, deadlineString, remindDate);
    }

    /**
     * Gets the correct command based on parameters supplied.
     * 
     * @param args full argument string
     * @param nameString name argument string
     * @param eventDatesString event dates argument string
     * @param deadlineString deadline dates argument string
     * @param remindDate reminder dates argument string
     * @return The correct command based on given arguments.
     */
    private Command getCorrectCommand(
            String args, String nameString, String eventDatesString, 
            String deadlineString, Date remindDate) {
        // Parse accordingly using DateParser and return the right command
        if (deadlineString != null && !deadlineString.isEmpty()) {
            List<Date> deadlineDates = DateParser.parse(deadlineString);
            return prepareDeadlineAdd(args, nameString, remindDate, deadlineDates);
        } else if (eventDatesString != null && !eventDatesString.isEmpty()) {
            List<Date> eventDates = DateParser.parse(eventDatesString);
            return prepareEventAdd(args, nameString, remindDate, eventDates);
        } else {
            return prepareFloatAdd(args, nameString, remindDate);
        }
    }

    /**
     * Prepares a float task with reminder.
     * 
     * @param args Full string for the argument.
     * @param name Name as extracted from argument.
     * @param remindDate Reminder date as extracted. Nullable.
     * @return a valid float Add Command.
     */
    private Command prepareFloatAdd(String args, String name, Date remindDate) {
        if (remindDate == null) {
            return new AddCommand(args);
        }

        return new AddCommand(name, null, null, remindDate);
    }

    /**
     * Prepares a deadline task add command with reminder date. returns
     * 
     * @param name Deadline task name
     * @param dates List of dates, should be 1 in order to prepare valid add command.
     * @param remindDate List of remind dates. Should be 1 only.
     * @return a valid add deadline or float command or an incorrectCommand
     */
    private Command prepareDeadlineAdd(String fullArgs, String name, Date remindDate, List<Date> dates) {
        // Check if number of dates given are valid
        if (dates == null || dates.size() > 1) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  AddCommand.MESSAGE_USAGE));
        }
        
        // No dates means we should fallback to adding a float
        if (dates.size() == 0) {
            return prepareFloatAdd(fullArgs, name, remindDate);
        }

        // Check if reminder was specified but reminder is invalid
        if(remindDate != null && checkInvalidReminderDate(remindDate, dates)) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  Messages.MESSAGE_REMINDER_AFTER_FINAL_DATE));
        }

        return generateDeadlineAddCommand(name, dates, remindDate);

    }

    /**
     * Prepares an event add command with reminder. Checks that number of dates
     * supplied is more than 2, otherwise returns Incorrect Command. Will
     * generate float or event add command accordingly.
     * 
     * @param name Event task name
     * @param dates List of dates, should contain 2 dates: start and end date to be valid.
     * @param remindDate List of reminder dates. Should contain 1 date only.
     * @return a valid add event or float command or an incorrectCommand
     */
    private Command prepareEventAdd(
            String fullArgs, String name, Date remindDate, List<Date> dates) {
        // Check if number of dates given are valid
        if (dates == null || dates.size() > 2) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  AddCommand.MESSAGE_USAGE));
        }

        // No dates given, fallback to preparing a float add
        if (dates.size() == 0) {
            return prepareFloatAdd(fullArgs, name, remindDate);
        }
        
        // Check if reminder was specified but reminder is invalid
        if(remindDate != null && checkInvalidReminderDate(remindDate, dates)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, Messages.MESSAGE_REMINDER_AFTER_FINAL_DATE));
        }
        
        return generateEventAddCommand(name, dates, remindDate);
    }
    
```
###### \java\taskle\logic\parser\AddCommandParser.java
``` java
    /**
     * Generates a deadline add command with reminder date
     * 
     * @param nameString name to be used for deadline add command
     * @param dates List of dates to be used to generate deadline. Should be 1.
     * @param remindDate reminder date. Nullable.
     * @return a valid deadline add command with reminder date
     */
    private AddCommand generateDeadlineAddCommand(
            String nameString, List<Date> dates, Date remindDate) {
        assert dates.size() == 1;
        return new AddCommand(nameString, null, dates.get(0), remindDate);
    }

    /**
     * Generates a event add command with reminder date
     * 
     * @param fullArgs full argument string
     * @param name name to be used for deadline add command
     * @param dates List of dates to be used to generate deadline. Should be 1.
     * @param remindDate List of dates to be used for reminder date. Should be 1.
     * @return a valid event add command with reminder date
     */
    private AddCommand generateEventAddCommand(
            String name, List<Date> dates, Date remindDate) {
        assert dates.size() == 1 || dates.size() == 2;

        // There are either 2 or 1 dates given, generate accordingly
        if (dates.size() == 2) {
            return new AddCommand(name, dates.get(0), dates.get(1), remindDate);
        } else {
            return new AddCommand(name, dates.get(0), dates.get(0), remindDate);
        }
    }

}
```
###### \java\taskle\logic\parser\ClearCommandParser.java
``` java

/**
 * Clear command parser class to handle parsing of clear commands.
 * @author Abel
 *
 */
public class ClearCommandParser extends CommandParser {

    public ClearCommandParser() {
    }
    
    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(ClearCommand.COMMAND_WORD);
    }

    @Override
    public Command parseCommand(String args) {
        return new ClearCommand();
    }

}
```
###### \java\taskle\logic\parser\CommandParser.java
``` java
/**
 * Base abstract class for all command parsers.
 * All new commands added must extend this class 
 * if you want to add a new command.
 * @author Abel
 *
 */
public abstract class CommandParser {
    
    private static final Pattern TASK_NAME_ARGS_FORMAT = 
            Pattern.compile("(?<targetName>.+)");
    
    private static final Pattern TASK_INDEX_ARGS_FORMAT = 
            Pattern.compile("(?<targetIndex>.+)");
    
    /**
     * Returns whether this command parser can parse the command with the given
     * command word.
     * 
     * @param commandWord Given command word.
     */
    public abstract boolean canParse(String commandWord);
    
    public abstract Command parseCommand(String args);
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned
     * integer is given as the index. Returns an {@code Optional.empty()}
     * otherwise.
     * 
     * @param command Full command string
     */
    protected Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }
        
        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
    
    /**
     * Returns the specified name in the command
     * 
     * @param command full command string
     * @return the name as specified in command
     */
    protected Optional<String> parseName(String command) {
        final Matcher matcher = TASK_NAME_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }
        
        String name = matcher.group("targetName");
        return Optional.of(name);
    }
    
}
```
###### \java\taskle\logic\parser\DateParser.java
``` java
/**
 * Parser class for handling date and time using the
 * Natty library.
 * @author Abel
 *
 */
public class DateParser {
    
    /**
     * Private constructor to prevent instantiation.
     */
    private DateParser() {
    }

    /**
     * Parses given date and time string and returns 
     * an array of date time that we are interested in capturing.
     * Usually start and end dates or just deadline date.
     * If no dates are found, empty list is returned.
     * 
     * @param dateTimeString String containing date and time to be parsed.
     * @return A list of Dates found in String.
     */
    public static List<Date> parse(String dateTimeString) {
        assert dateTimeString != null && !dateTimeString.isEmpty();
        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(dateTimeString);
        if (groups.isEmpty() || groups.get(0) == null) {
            return new ArrayList<>();
        }
        
        // We are only interested in the first date group
        DateGroup group = groups.get(0);
        List<Date> dates = group.getDates();
        
        // If time is inferred and not explicitly stated by user
        // We reset time because it would produce the current time
        boolean isTimeInferred = group.isTimeInferred();
        if (isTimeInferred) {
            resetTime(dates);
        }
        
        return dates;
    }
    
    /**
     * Parses a given string as a reminder date string and 
     * returns the corresponding date. If no date is found, 
     * returned value is a null.
     * 
     * @param remindString string containing reminder date
     * @return Date value from parsing the string.
     */
    public static Date parseRemindDate(String remindString) {
        if (remindString == null || remindString.isEmpty()) {
            return null;
        }
        
        List<Date> dates = parse(remindString);
        if (dates == null || dates.isEmpty() || dates.size() != 1) {
            return null;
        }
        
        return dates.get(0);
    }
    
    /**
     * Resets the time fields in the list of dates to zeroes.
     * 
     * @param dates List of dates to be reset.
     */
    private static void resetTime(List<Date> dates) {
        if (dates == null) {
            return;
        }
        
        for (Date date: dates) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(date);
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 59);
            calendar.set(Calendar.MILLISECOND, 0);
            date.setTime(calendar.getTime().getTime());
        }
    }
}
```
###### \java\taskle\logic\parser\FindCommandParser.java
``` java
/**
 * FindCommandParser class to handle parsing of Find Commands.
 * @author Abel
 *
 */
public class FindCommandParser extends CommandParser {

    // one or more keywords separated by whitespace
    private static final Pattern FIND_KEYWORDS_ARG_FORMAT = 
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)");
    
    // one or more keywords separated by whitespace
    private static final Pattern FIND_STATUS_ARGS_FORMAT = 
            Pattern.compile("(?:-(?:(?<all>all)|"
                    + "(?<done>done)|"
                    + "(?<overdue>overdue)|"
                    + "(?<pending>pending))(?:\\s|$))+");
    
    public FindCommandParser() {
    }

    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(FindCommand.COMMAND_WORD)
               || commandWord.equals(FindCommand.COMMAND_WORD_SHORT);
    }

    @Override
    public Command parseCommand(String args) {
        return prepareFind(args);
    }
    
    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareFind(String args) {
        // Check if number of arguments given are correct
        String[] argParams = args.trim().split("-", 2);
        if (argParams[0].isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  FindCommand.MESSAGE_USAGE));
        }
        
        String keywordsParam = argParams[0].trim();
        String statusesParam = "";
        if (argParams.length == 2) {
            statusesParam = "-" + argParams[1];
        }
        
        Matcher keywordMatcher = FIND_KEYWORDS_ARG_FORMAT.matcher(keywordsParam);
        Matcher statusMatcher = FIND_STATUS_ARGS_FORMAT.matcher(statusesParam);
        
        // Check keywords and params
        if (!keywordsParam.isEmpty() && !keywordMatcher.matches() 
            || !statusesParam.isEmpty() && !statusMatcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  FindCommand.MESSAGE_USAGE));
        }
        
        // get keywords delimited by whitespace
        final String[] keywords = keywordMatcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        
        return generateFindCommand(statusesParam, keywordSet, statusMatcher);
    }
    
    private FindCommand generateFindCommand(
            String statusesParam, Set<String> keywordSet, Matcher statusMatcher) {
        if (statusesParam.isEmpty()) {
            return new FindCommand(keywordSet);
        }
        
        return getStatusFindCommand(statusMatcher, keywordSet);
    }
    
    /**
     * Parses and returns a Find Command base on filters set in status matcher
     * and the keywords as defined in keywordSet.
     * @param statusMatcher status matcher that contains the status flags.
     * @param keywordSet set of keywords to find
     * @return
     */
    private FindCommand getStatusFindCommand(Matcher statusMatcher, Set<String> keywordSet) {
        String done = statusMatcher.group("done");
        String pending = statusMatcher.group("pending");
        String overdue = statusMatcher.group("overdue");
        String all = statusMatcher.group("all");
        
        if (all != null) {
            return new FindCommand(keywordSet, true, true, true);
        }
        
        return new FindCommand(
                keywordSet, pending != null, 
                done != null, overdue != null);
    }

}
```
###### \java\taskle\logic\parser\ListCommandParser.java
``` java
/**
 * ListCommandParser class to handle parsing of list commands.
 * @author Abel
 *
 */
public class ListCommandParser extends CommandParser {

    // one or more keywords separated by whitespace
    private static final Pattern LIST_KEYWORDS_ARGS_FORMAT = 
            Pattern.compile("(?:-(?:(?<all>all)|"
                    + "(?<done>done)|"
                    + "(?<overdue>overdue)|"
                    + "(?<pending>pending))(?:\\s|$))+");
    
    public ListCommandParser() {
    }

    @Override
    public boolean canParse(String commandWord) {
        assert (commandWord != null && !commandWord.isEmpty());
        return commandWord.equals(ListCommand.COMMAND_WORD)
                || commandWord.equals(ListCommand.COMMAND_WORD_SHORT);
    }

    @Override
    public Command parseCommand(String args) {
        return prepareList(args);
    }

    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args) {
        final Matcher matcher = 
                LIST_KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        
        if (!args.isEmpty() && !matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  ListCommand.MESSAGE_USAGE));
        }
        
        return generateListCommand(args, matcher);
    }
    
    /**
     * Generates a list command according to the given args parameters
     * and the groups as matched by the given matcher.
     * 
     * @param args full command argument string
     * @param matcher Matcher on argument string
     * @return Corresponding List Command
     */
    private Command generateListCommand(String args, Matcher matcher) {
        if (args.isEmpty()) {
            return new ListCommand(true, false, true);
        }
        
        String done = matcher.group("done");
        String pending = matcher.group("pending");
        String overdue = matcher.group("overdue");
        String all = matcher.group("all");
        
        if (all != null) {
            return new ListCommand(true, true, true);
        }
        
        return new ListCommand(pending != null, done != null, overdue != null);
    }
    
}
```
###### \java\taskle\logic\parser\Parser.java
``` java

/**
 * Parses user input.
 */
public class Parser {

    /** Used for initial separation of command word and args. */
    private static final Pattern BASIC_COMMAND_FORMAT = 
            Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");
        
    private List<CommandParser> commandParsers;

    public Parser() {
        setupParsers();
    }

    /**
     * Sets up the list of command parsers required.
     * All commands have to implement a command parser and instantiate it
     * in this method for parser to parse it as a command.
     */
    private void setupParsers() {
        // Generate a list of command parsers here, every new 
        // command added must be added to the commandParsers list here
        commandParsers = new ArrayList<>(
                Arrays.asList(new AddCommandParser(),
                              new RemoveCommandParser(),
                              new EditCommandParser(),
                              new FindCommandParser(),
                              new ListCommandParser(),
                              new UndoCommandParser(),
                              new RedoCommandParser(),
                              new DoneCommandParser(),
                              new HelpCommandParser(),
                              new ClearCommandParser(),
                              new ExitCommandParser(),
                              new RescheduleCommandParser(),
                              new RemindCommandParser(),
                              new OpenFileCommandParser(),
                              new ChangeDirectoryCommandParser()));
        
        /** Parse a date using date parser on start up to reduce
         * command delay on first parse. (Natty library constraints) */
        DateParser.parse("today");
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                                  HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        return prepareCommand(commandWord, arguments);
    }
    
    /**
     * Prepares commmand based on command word and arguments.
     * 
     * @param commandWord command word from user input.
     * @param args arguments after command word from user input.
     * @return The corresponding command to the command word after parsing. 
     */
    private Command prepareCommand(String commandWord, String args) {
        if (commandWord == null || commandWord.isEmpty()) {
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
        
        for (CommandParser commandParser : commandParsers) {
            if (commandParser.canParse(commandWord)) {
                return commandParser.parseCommand(args);
            }
        }
        
        return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
    }

}
```
###### \java\taskle\model\help\CommandGuide.java
``` java
/**
 * Model class to encapsulate the information provided
 * by each row in the help window. *
 */
public class CommandGuide {
    
    // Member variables for a CommandGuide object
    private String actionName;
    private String commandWord;
    private String shortcutCommand;
    private String[] args; 
    
    /**
     * Constructor for CommandGuide
     * Asserts that name and commandWord are non-null because it is
     * constructed by custom parameters in HelpWindow always.
     * 
     * @param name Name of the action and command
     * @param commandWord command keyword
     * @param args optional arguments for command keyword
     */
    public CommandGuide(String name, String shortCommand, String commandWord, String... args) {
        assert name != null;
        assert commandWord != null;
        this.actionName = name;
        this.commandWord = commandWord;
        this.shortcutCommand = shortCommand;
        this.args = args;
    }
    
    public String getName() {
        return actionName;
    }
    
    public String getCommandWord() {
        return commandWord;
    }
    
    public String getShortcutCommand() {
        return shortcutCommand;
    }
    public String[] getArgs() {
        return args;
    }
}
```
###### \java\taskle\model\Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();
    
    /** Updates the filter of the filtered task list to show tasks filtered by predicates*/
    void updateFilteredListWithStatuses();
    
    /** Updates the filter status predicates*/
    void updateFilters(boolean pending, boolean done, boolean overdue);

    /** Updates the filter keywords predicates*/
    void updateFilters(Set<String> keywords);
    
    /** Updates the filter statuses and keywords predicates*/
    void updateFilters(Set<String>keywords, boolean pending, 
                       boolean done, boolean overdue);

}
```
###### \java\taskle\model\ModelManager.java
``` java
    //=========== Filtered Task List Accessors ===============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }
    
    @Override
    public void updateFilteredListWithStatuses() {
        filteredTasks.setPredicate(getStatusPredicate());
    }
    
    @Override
    public void updateFilters(Set<String> keywords){
        updateFilteredListFindKeywords(keywords);
    }
    
    @Override
    public void updateFilters(Set<String> keywords, boolean isPendingShown, 
                              boolean isDoneShown, boolean isOverdueShown){
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
        raise(new TaskFilterChangedEvent(isPendingShown, isDoneShown, isOverdueShown));
        updateFilteredListFindKeywords(keywords);
    }
    
    @Override
    public void updateFilters(
            boolean isPendingShown, boolean isDoneShown, boolean isOverdueShown) {
        this.isPendingShown = isPendingShown;
        this.isDoneShown = isDoneShown;
        this.isOverdueShown = isOverdueShown;
        raise(new TaskFilterChangedEvent(isPendingShown, isDoneShown, isOverdueShown));
        updateFilteredListWithStatuses();
    }
    
    private void updateFilteredListFindKeywords(Set<String> keywords) {
        Expression keywordExpression = new PredicateExpression(new NameQualifier(keywords));
        Predicate<Task> statusPred = getStatusPredicate();
        Predicate<Task> combinedPred = statusPred.and(keywordExpression::satisfies);
        filteredTasks.setPredicate(combinedPred);
    }
    
    /**
     * Returns the predicate to use for filtering as specified by 
     * the show status boolean fields.
     * @return
     */
    private Predicate<Task> getStatusPredicate() {
        Predicate<Task> basePred = t -> false;
        Predicate<Task> pendingPred = t -> t.getStatus() == Status.PENDING
                || t.getStatus() == Status.FLOAT;
        Predicate<Task> donePred = t -> t.getStatus() == Status.DONE;
        Predicate<Task> overduePred = t -> t.getStatus() == Status.OVERDUE;
        
        if (isPendingShown) {
            basePred = basePred.or(pendingPred);
        }
        
        if (isDoneShown) {
            basePred = basePred.or(donePred);
        }
        
        if (isOverdueShown) {
            basePred = basePred.or(overduePred);
        }
        
        return basePred;
    }
```
###### \java\taskle\model\task\DeadlineTask.java
``` java
/**
 * Deadline task object that guarantees non-null fields for task and nullable
 * field for deadlineDate.
 * 
 * @author Abel
 *
 */
public class DeadlineTask extends Task {

    private Date deadlineDate;

    public DeadlineTask(Name name, Date deadlineDate) {
        super(name);
        this.deadlineDate = deadlineDate;
    }
    
    public DeadlineTask(Name name, Date deadlineDate, Date remindDate) {
        super(name, remindDate);
        this.deadlineDate = deadlineDate;
    }
    

    public DeadlineTask(ReadOnlyTask source) {
        super(source);
        
        if (source instanceof DeadlineTask) {
            deadlineDate = ((DeadlineTask) source).getDeadlineDate();
        }
    }

    @Override
    public String getDetailsString() {
        return DateFormatUtil.formatSingleDate(deadlineDate);
    }

    public Date getDeadlineDate() {
        return deadlineDate;
    }

    public void setDeadlineDate(Date deadlineDate) {
        this.deadlineDate = deadlineDate;
    }
        
    @Override
    public Task copy() {
        return new DeadlineTask(this);
    }

    /**
     * Converts the task into a string that can represent its addition in a
     * command as well.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(name);
        builder.append(" by ");
        builder.append(getDetailsString());
        return builder.toString();
    }

    @Override
    public Status getStatus() {
        Calendar calendar = Calendar.getInstance();
        Date nowDate = calendar.getTime();
        if (isTaskDone) { 
            return Status.DONE;
        } else if (nowDate.before(deadlineDate)) {
            return Status.PENDING;
        } else {
            return Status.OVERDUE;
        }
    }

}
```
###### \java\taskle\model\task\EventTask.java
``` java
/**
 * Event task object that guarantees non-null fields for task
 * and nullable fields for event start and end dates.
 * @author Abel
 *
 */
public class EventTask extends Task {
        
    private Date startDate;
    private Date endDate;
    
    public EventTask(Name name, Date startDateTime, Date endDateTime) {
        super(name);
        this.startDate = startDateTime;
        this.endDate = endDateTime;
    }

    public EventTask(Name name, Date startDateTime, Date endDateTime, Date remindDate) {
        super(name, remindDate);
        this.startDate = startDateTime;
        this.endDate = endDateTime;
    }
    
    public EventTask(ReadOnlyTask source) {
        super(source);
        
        if (source instanceof EventTask) {
            EventTask event = (EventTask) source;
            startDate = event.getStartDate();
            endDate = event.getEndDate();
        }
    }

    @Override
    public String getDetailsString() {
        return DateFormatUtil.formatEventDates(startDate, endDate);
    }
    
    public Date getEndDate() {
        return endDate;
    }
    
    public Date getStartDate() {
        return startDate;
    }
   
    public void setEndDate(Date endDate) {
        this.endDate = endDate;
    }
    
    public void setStartDate(Date startDate) {
        this.startDate = startDate;
    }
   
    @Override
    public Task copy() {
        return new EventTask(this);
    }
    
    /**
     * Converts the task into a string that can represent
     * its addition in a command as well.
     */
    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append(name);
        builder.append(" from ");
        builder.append(getDetailsString());
        return builder.toString();
    }

    @Override
    public Status getStatus() {
        if (isTaskDone) {
            return Status.DONE;
        }
        
        Calendar calendar = Calendar.getInstance();
        Date nowDate = calendar.getTime();
        if (nowDate.before(startDate)) {
            return Status.PENDING;
        } else {
            return Status.OVERDUE;
        }
    }

}
```
###### \java\taskle\model\task\FloatTask.java
``` java
/**
 * A Task with no other details like time and dates.
 * It only guarantees a task name.
 * @author Abel
 *
 */
public class FloatTask extends Task {

    public FloatTask(Name name) {
        super(name);
    }
    
    public FloatTask(Name name, Date remindDate) {
        super(name, remindDate);
    }
    
    /**
     * Copy constructor.
     */
    public FloatTask(ReadOnlyTask source) {
        super(source);
    }
    
    @Override
    public String getDetailsString() {
        return "";
    }

    @Override
    public Task copy() {
        return new FloatTask(this);
    }

    @Override
    public Status getStatus() {
        if (isTaskDone) {
            return Status.DONE;
        }
        
        return Status.FLOAT;
    }
    
}
```
###### \java\taskle\ui\CommandBox.java
``` java
    public void configure(NotificationPane notificationPane, 
                          Logic logic) {
        this.notificationPane = notificationPane;
        this.logic = logic;
        createPopOver();
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }
    
    /** Creates a pop over with content layout and style specified. */
    private void createPopOver() {
        popOver = new PopOver();
        popOver.setId(POP_OVER_ID);
        setPopOverLayout();
        setPopOverStyle();
    }
    
    /** Sets up the layout inside popover. */
    private void setPopOverLayout() {
        popOverText = new Text();
        popOverText.setId(POP_OVER_TEXT_ID);
        
        VBox vBox = new VBox();
        vBox.getChildren().add(popOverText);
        vBox.setPadding(new Insets(10));
        popOver.setContentNode(vBox);
    }
    
    /** Sets up the style for popover and how it is displayed. */
    private void setPopOverStyle() {
        popOver.setArrowLocation(ArrowLocation.BOTTOM_CENTER);
        popOver.setFadeInDuration(new Duration(300));
        popOver.setDetachable(false);
        popOver.setAutoHide(true);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    /**
     * Java FXML method that is called everytime there's a 
     * new command input.
     */
    @FXML
    private void handleCommandInputChanged() {
        //Take a copy of the command text
        previousCommandText = commandTextField.getText();
        
        // execute command and display command feedback
        mostRecentResult = logic.execute(previousCommandText);
        displayCommandFeedback(mostRecentResult);
        logger.info("Result: " + mostRecentResult.getFeedback());
    }
    
    /**
     * Displays command feedback based on results.
     * If result is not successful, no feedback is displayed.
     * If successful, feedback is displayed.
     * 
     * @param commandResult Command result to use for display.
     */
    private void displayCommandFeedback(CommandResult commandResult) {
        assert commandResult != null;
        
        String feedback = commandResult.getFeedback();
        if (!commandResult.isSuccessful()) {
            return;
        }
        
        showCorrectCommand(feedback);
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandText));
        showIncorrectCommand(event.getFeedback());
        restoreCommandText();
    }

    /**
     * Shows the UI elements for incorrect command.
     * 
     * @param feedback feedback message to user to incorrect command.
     */
    private void showIncorrectCommand(String feedback) {
        popOverText.setText(feedback);
        popOver.show(commandTextField);
        notificationPane.hide();
    }
    
    /**
     * Shows the UI elements for correct command.
     * 
     * @param feedback feedback message to user for correct command.
     */
    private void showCorrectCommand(String feedback) {
        popOver.hide();
        commandTextField.clear();
        notificationPane.show(feedback);
    }
    
    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandText);
        commandTextField.positionCaret(previousCommandText.length());
    }

}
```
###### \java\taskle\ui\HelpTableCell.java
``` java
/**
 * Custom Help Table Cell that uses TextFlow to set custom 
 * colors for Help Window texts.
 *
 */
public class HelpTableCell extends TableCell<CommandGuide, String> {
    
    private static final String REGEX_SPACE_SPLIT = "\\s+";
    private static final int INDEX_COMMAND_WORD = 0;
    private static final String SPACE = " ";

    @Override
    protected void updateItem(String str, boolean empty) {
        if (str != null) {
            TextFlow flow = new TextFlow();
            String[] strings = str.split(REGEX_SPACE_SPLIT);
            assert strings.length > 0;
            setCommandWordStyle(flow, strings);
            setArgsStyle(flow, strings);
            flow.setPrefHeight(10);
            setGraphic(flow);
        }
    }
    
    /**
     * This method sets the style of the command word in format rows.
     * 
     * @param flow TextFlow for the row.
     * @param strings Strings to be binded to row.
     */
    private void setCommandWordStyle(TextFlow flow, String[] strings) {
        Text commandText = new Text(strings[INDEX_COMMAND_WORD]);
        commandText.setFill(Color.WHITE);
        flow.getChildren().add(commandText);
    }
    
    /**
     * This method sets the style of the arguments in format rows.
     * 
     * @param flow TextFlow for the row.
     * @param strings Strings to be binded to row.
     */
    private void setArgsStyle(TextFlow flow, String[] strings) {
        for (int i = 1; i < strings.length; i++) {
            switch (i) {
            case 1:
                Text argText = new Text(SPACE + strings[i]);
                argText.setFill(Color.DARKORANGE);
                argText.setWrappingWidth(Double.MAX_VALUE);
                flow.getChildren().add(argText);
                break;
            default:
                Text timeArgText = new Text(SPACE + strings[i]);
                timeArgText.setFill(Color.LIGHTGREEN);
                timeArgText.setWrappingWidth(Double.MAX_VALUE);
                flow.getChildren().add(timeArgText);
                break;
            }
        }
    }
}
```
###### \java\taskle\ui\HelpWindow.java
``` java
/**
 * Controller for a help page
 */
public class HelpWindow extends UiPart {

    private static final String SPACE_STRING = " ";
    private static final String COLUMN_NAME_FORMAT = "Command Format";
    private static final String COLUMN_NAME_ACTION = "Action";
    private static final String COLUMN_NAME_SHORTCUT = "Shortcut";
    private static final Logger logger = LogsCenter.getLogger(HelpWindow.class);
    private static final String ICON = "/images/help_icon.png";
    private static final String FXML = "HelpWindow.fxml";
    private static final String TITLE = "Help";
    
    // List of command guides to be used for help page
    private static final List<CommandGuide> LIST_COMMAND_GUIDES = new ArrayList<>(
            Arrays.asList(new CommandGuide("Addition of Tasks", AddCommand.COMMAND_WORD_SHORT, AddCommand.COMMAND_WORD,
                            "task_name", "[remind date time]"),
                    new CommandGuide("", "", AddCommand.COMMAND_WORD, "task_name", "by", 
                            "date [time]", "[remind date time]"),
                    new CommandGuide("", "", AddCommand.COMMAND_WORD, "task_name", "from", 
                            "date [time]", "to", "date [time]", "[remind date time]"),
                    new CommandGuide("Editing of Tasks", EditCommand.COMMAND_WORD_SHORT, EditCommand.COMMAND_WORD, 
                            "task_number", "new_task_name"),
                    new CommandGuide("", RescheduleCommand.COMMAND_WORD_SHORT, RescheduleCommand.COMMAND_WORD,
                            "task_number", "date [time]", "[to date time]", "[remind date time]"),
                    new CommandGuide("", "", RescheduleCommand.COMMAND_WORD, 
                            "task_number", "clear"),
                    new CommandGuide("", RemindCommand.COMMAND_WORD_SHORT, RemindCommand.COMMAND_WORD, 
                            "task_number", "date [time]"),
                    new CommandGuide("", "" , RemindCommand.COMMAND_WORD,
                            "task_number", "clear"),
                    new CommandGuide("Removal of Tasks", RemoveCommand.COMMAND_WORD_SHORT, RemoveCommand.COMMAND_WORD,
                            "task_number"), 
                    new CommandGuide("Undo Previous Command", UndoCommand.COMMAND_WORD_SHORT, UndoCommand.COMMAND_WORD),
                    new CommandGuide("Redo Previous Command", RedoCommand.COMMAND_WORD_SHORT, RedoCommand.COMMAND_WORD),
                    new CommandGuide("Finding of Tasks", FindCommand.COMMAND_WORD_SHORT, FindCommand.COMMAND_WORD, 
                            "keywords", "[-status]"),
                    new CommandGuide("Listing of Tasks", ListCommand.COMMAND_WORD_SHORT, ListCommand.COMMAND_WORD, 
                            "[-status]"),
                    new CommandGuide("Marking Tasks as Done", DoneCommand.COMMAND_WORD_SHORT, DoneCommand.COMMAND_WORD, 
                            "task_number"),
                    new CommandGuide("Clearing of Tasks", "", ClearCommand.COMMAND_WORD),
                    new CommandGuide("Changing of Save Directory", ChangeDirectoryCommand.COMMAND_WORD_SHORT,
                            ChangeDirectoryCommand.COMMAND_WORD, "directory_path"),
                    new CommandGuide("Opening of File", OpenFileCommand.COMMAND_WORD_SHORT, OpenFileCommand.COMMAND_WORD,
                            "file_path"),
                    new CommandGuide("Help Window Display", HelpCommand.COMMAND_WORD_SHORT, HelpCommand.COMMAND_WORD),
                    new CommandGuide("Exiting from Taskle", "", ExitCommand.COMMAND_WORD)));

    private AnchorPane mainPane;
    private Stage dialogStage;

    @FXML
    private TableView<CommandGuide> helpTable;

    public static HelpWindow load(Stage primaryStage) {
        logger.fine("Showing help page about the application.");
        HelpWindow helpWindow = UiPartLoader.loadUiPart(primaryStage, new HelpWindow());
        helpWindow.configure();
        return helpWindow;
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    private void configure() {
        Scene scene = new Scene(mainPane);
        // Null passed as the parent stage to make it non-modal.
        dialogStage = createDialogStage(TITLE, null, scene);
        dialogStage.setMaximized(false);
        setIcon(dialogStage, ICON);
        setupHelpTable();
    }

    private void setupHelpTable() {
        ObservableList<CommandGuide> observableGuides = 
                FXCollections.observableArrayList(LIST_COMMAND_GUIDES);
        helpTable.setItems(observableGuides);
        setupHelpColumns();
    }

    private void setupHelpColumns() {
        setupNameCol();
        setupShortcutCol();
        setupFormatCol();
    }

    private void setupNameCol() {
        TableColumn<CommandGuide, String> nameCol = 
                new TableColumn<>(COLUMN_NAME_ACTION);
        bindNameColString(nameCol);
        setNameColStyle(nameCol);
        nameCol.setSortable(false);
        helpTable.getColumns().add(nameCol);
    }

    private void setupShortcutCol() {
        TableColumn<CommandGuide, String> shortcutCol = 
                new TableColumn<>(COLUMN_NAME_SHORTCUT);
        bindShortcutColString(shortcutCol);
        setShortcutColStyle(shortcutCol);
        shortcutCol.setSortable(false);
        helpTable.getColumns().add(shortcutCol);
    }
    
    private void setupFormatCol() {
        TableColumn<CommandGuide, String> formatCol = 
                new TableColumn<>(COLUMN_NAME_FORMAT);
        bindFormatColString(formatCol);
        setFormatColStyle(formatCol);
        formatCol.setSortable(false);
        helpTable.getColumns().add(formatCol);
    }

    /**
     * This method binds the Strings for name columns to the CommandGuide 
     * objects.
     * 
     * @param nameCol Name Column for help window
     */
    private void bindNameColString(TableColumn<CommandGuide, String> nameCol) {
        nameCol.setCellValueFactory(
                new Callback<CellDataFeatures<CommandGuide, String>, 
                ObservableValue<String>>() {
            @Override
            public ObservableValue<String> call(CellDataFeatures<CommandGuide, String> param) {
                String actionName = param.getValue().getName();
                return getNameColString(actionName);
            }
        });
    }

    /**
     * This method binds the Strings for format columns to the CommandGuide
     * objects.
     * 
     * @param formatCol Format Column for help window
     */
    private void bindShortcutColString(TableColumn<CommandGuide, String> formatCol) {
        formatCol.setCellValueFactory(
                new Callback<CellDataFeatures<CommandGuide, String>, 
                ObservableValue<String>>() {
            @Override
            public ObservableValue<String> call(CellDataFeatures<CommandGuide, String> param) {
                CommandGuide commandGuide = param.getValue();
                String shortcutCommand = commandGuide.getShortcutCommand();
                return getShortcutColString(shortcutCommand);
            }
        });
    }
    
    /**
     * This method binds the Strings for format columns to the CommandGuide
     * objects.
     * 
     * @param formatCol Format Column for help window
     */
    private void bindFormatColString(TableColumn<CommandGuide, String> formatCol) {
        formatCol.setCellValueFactory(
                new Callback<CellDataFeatures<CommandGuide, String>, 
                ObservableValue<String>>() {
            @Override
            public ObservableValue<String> call(CellDataFeatures<CommandGuide, String> param) {
                CommandGuide commandGuide = param.getValue();
                String commandWord = commandGuide.getCommandWord();
                String[] commandArgs = commandGuide.getArgs();
                return getFormatColString(commandWord, commandArgs);
            }
        });
    }

    private void setNameColStyle(TableColumn<CommandGuide, String> nameCol) {
        nameCol.prefWidthProperty().bind(helpTable.widthProperty().multiply(0.27));
        nameCol.setResizable(false);
    }
    
    private void setShortcutColStyle(TableColumn<CommandGuide, String> shortcutCol) {
        shortcutCol.prefWidthProperty().bind(helpTable.widthProperty().multiply(0.13));
        shortcutCol.setResizable(false);
    }

    private void setFormatColStyle(TableColumn<CommandGuide, String> formatCol) {
        formatCol.prefWidthProperty().bind(helpTable.widthProperty().multiply(0.6));
        formatCol.setResizable(false);
        formatCol.setCellFactory(
                new Callback<TableColumn<CommandGuide, String>, 
                TableCell<CommandGuide, String>>() {
            @Override
            public HelpTableCell call(TableColumn<CommandGuide, String> param) {
                return new HelpTableCell();
            }});
    }

    private ObservableValue<String> getNameColString(String name) {
        return new SimpleStringProperty(name);
    }

    private ObservableValue<String> getFormatColString(String commandWord, String... args) {
        String argsStrings = String.join(SPACE_STRING, args);
        return new SimpleStringProperty(String.join(SPACE_STRING, commandWord, argsStrings));
    }

    private ObservableValue<String> getShortcutColString(String shortcutCommand) {
        return new SimpleStringProperty(shortcutCommand);
    }
    
    public void show() {
        dialogStage.showAndWait();
    }
}
```
###### \java\taskle\ui\MainWindow.java
``` java
    private void configure(String appTitle, String taskManagerName, Config config, UserPrefs prefs,
                           Logic logic) {

        //Set dependencies
        this.logic = logic;
        this.config = config;
        this.userPrefs = prefs;

        //Configure the UI
        setTitle(appTitle);
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        
        setupNotificationPane();
        scene = new Scene(notificationPane);
        primaryStage.setScene(scene);

        setCustomFont();
        setAccelerators();
    }
    
    private void setCustomFont() {
        scene.getStylesheets().add(GOOGLE_CUSTOM_FONT_URL);
    }

    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
    }

    void fillInnerParts() {
        taskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        statusDisplayPanel = StatusDisplayPanel.load(primaryStage, getStatusDisplayPanelPlaceholder());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), notificationPane, logic);
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }
    
    private AnchorPane getStatusDisplayPanelPlaceholder() {
        return statusDisplayPanelPlaceholder;
    }

    public AnchorPane getTaskListPlaceholder() {
        return taskListPanelPlaceholder;
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        Point windowCoords = prefs.getGuiSettings().getWindowCoordinates();
        if (windowCoords != null && windowCoords.getX() > 0 && windowCoords.getY() > 0) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }
    

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

```
###### \java\taskle\ui\StatusDisplayPanel.java
``` java
/**
 * A ui for the status display panel that is displayed on top of the command box
 * in the application.
 */
public class StatusDisplayPanel extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(StatusDisplayPanel.class);

    private HBox mainPane;

    @FXML
    private Label displayLabel;
        
    @FXML
    private ImageView allChip;
    
    @FXML
    private ImageView pendingChip;

    @FXML
    private ImageView overdueChip;
    
    @FXML
    private ImageView doneChip;

    private AnchorPane placeHolder;

    private static final String FXML = "StatusDisplayPanel.fxml";

    public static StatusDisplayPanel load(Stage stage, AnchorPane placeHolder) {
        StatusDisplayPanel statusDisplayPanel = UiPartLoader.loadUiPart(stage, placeHolder, new StatusDisplayPanel());
        statusDisplayPanel.configure();
        return statusDisplayPanel;
    }

    public void configure() {
        addMainPane();
        setupInitialChips();
        registerAsAnEventHandler(this);
    }

    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (HBox) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    /**
     * Prepares the initial chips, namely the pending and overdue chips and
     * the display label.
     */
    private void setupInitialChips() {
        ObservableList<Node> nodes = mainPane.getChildren();
        nodes.clear();
        nodes.add(displayLabel);
        nodes.add(pendingChip);
        nodes.add(overdueChip);
    }

    @Subscribe
    private void handleTaskFilterChangedEvent(TaskFilterChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        ObservableList<Node> nodes = mainPane.getChildren();
        nodes.clear();
        nodes.add(displayLabel);
        updateNodes(nodes, event);
    }
    
    /**
     * Updates the nodes to reflect the TaskFilterChangedEvent.
     * 
     * @param nodes List of nodes used.
     * @param event Event that reflects the new filters.
     */
    private void updateNodes(
            ObservableList<Node> nodes, TaskFilterChangedEvent event) {
        if (event.isAllShown) {
            nodes.add(allChip);
            return;
        }
        
        updatePendingNode(nodes, event);
        updateDoneNode(nodes, event);
        updateOverdueNode(nodes, event);
    }
    
    private void updatePendingNode(ObservableList<Node> nodes, 
                                   TaskFilterChangedEvent event) {
        if (event.isPendingShown) {
            nodes.add(pendingChip);
        }
    }
    
    private void updateDoneNode(ObservableList<Node> nodes, 
                                TaskFilterChangedEvent event) {
        if (event.isDoneShown) {
            nodes.add(doneChip);
        } 
    }
    
    private void updateOverdueNode(ObservableList<Node> nodes, 
                                   TaskFilterChangedEvent event) {
        if (event.isOverdueShown) {
            nodes.add(overdueChip);
        }
    }
    
    
    
}
```
###### \java\taskle\ui\TaskCard.java
``` java
public class TaskCard extends UiPart {

    private static final String STYLE_CARD_BG_DEFAULT = "-fx-background-color: #546E7A";
    private static final String STYLE_CARD_BG_DONE = "-fx-background-color: #455A64";
    
    private static final String FXML = "TaskListCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label details;
    @FXML
    private Label id;
    @FXML
    private Label reminderDate;
    @FXML
    private Rectangle colorTag;
    
    private ReadOnlyTask task;
    private int displayedIndex;

    public TaskCard(){

    }

    public static TaskCard load(ReadOnlyTask task, int displayedIndex){
        TaskCard card = new TaskCard();
        card.task = task;
        card.displayedIndex = displayedIndex;
        return UiPartLoader.loadUiPart(card);
    }

    @FXML
    public void initialize() {
        setCardTexts();
        setCardStyle();
    }
 
    private void setCardTexts() {
        name.setText(task.getName().fullName);
        details.setText(task.getDetailsString());
        reminderDate.setText(task.getRemindDetailsString());
        id.setText(displayedIndex + ". ");
    }
    
    private void setCardStyle() {
        cardPane.setStyle(STYLE_CARD_BG_DEFAULT);
        
        switch (task.getStatus()) {
        case DONE:
            colorTag.setFill(Color.MEDIUMSEAGREEN);
            cardPane.setStyle(STYLE_CARD_BG_DONE);
            break;
        case OVERDUE:
            colorTag.setFill(Color.ORANGERED);
            break;
        default:
            colorTag.setFill(Color.DODGERBLUE);
            break;
        }
    }

    public HBox getLayout() {
        return cardPane;
    }

    @Override
    public void setNode(Node node) {
        cardPane = (HBox)node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
}
```
###### \resources\view\DarkTheme.css
``` css
.background {
    -fx-background-color: #37474F;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Calibri";
    -fx-text-fill: white;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-status-display {
    -fx-font-size: 14pt;
    -fx-font-family: "Roboto Condensed";
	-fx-font-weight: Bold;
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.table-view {
    -fx-base: #37474F;
    -fx-control-inner-background: #37474F;
    -fx-background-color: #37474F;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-width: 0 0 1 0;
    -fx-background-color: transparent;
    -fx-border-color:
        transparent
        transparent
        derive(-fx-base, 80%)
        transparent;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 20pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-alignment: center-left;
    -fx-opacity: 1;
}

.table-view:focused .table-row-cell:filled:focused:selected {
    -fx-background-color: -fx-focus-color;
}

.split-pane:horizontal .split-pane-divider {
    -fx-border-color: #37474F;
    -fx-background-color: transparent, #37474F;
}

.split-pane {
    -fx-background-color: #37474F;
}

.list-cell {
	-fx-background-color: #37474F;
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 2 0 2 0;
}

.list-cell .label {
    -fx-text-fill: white;
}

.cell_big_label {
    -fx-font-size: 20px;
    -fx-text-fill: white;
}

.header_label {
    -fx-font-size: 20px;
    -fx-text-fill: white;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: white;
}

.anchor-pane {
     -fx-background-color: #37474F;
}

.anchor-pane-with-border {
     -fx-background-color: #37474F;
     -fx-border-color: #37474F;
}

.status-bar {
    -fx-background-color: #37474F;
    -fx-text-fill: black;
}

.result-display {
    -fx-background-color: #37474F;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: #37474F;
    -fx-border-width: 1px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.status-display-pane {
    -fx-background-color: #37474F;
}

.grid-pane {
    -fx-background-color: #37474F;
    -fx-border-color: #37474F;
    -fx-border-width: 1px;
}

.header-grid-pane {
    -fx-background-color: #37474F;
    -fx-border-color: #37474F;
}

.grid-pane .anchor-pane {
    -fx-background-color: #37474F;
}

.context-menu {
    -fx-background-color: #37474F
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color: #37474F
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: #37474F;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #37474F;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #37474F;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: #37474F;
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .thumb {
    -fx-background-color: derive(#1d1d1d, 50%);
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-color:#37474F;
    -fx-border-width: 1 1 1 1;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #taskListPanel {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}
```
###### \resources\view\HelpWindow.fxml
``` fxml
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.TableView?>
<?import java.net.URL?>
<AnchorPane fx:id="helpWindowRoot" maxHeight="Infinity"
	maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity"
	stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8"
	xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.HelpWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<TableView fx:id="helpTable" minHeight="650" minWidth="880"
			AnchorPane.topAnchor="0.0" AnchorPane.bottomAnchor="0.0"
			AnchorPane.rightAnchor="0.0" AnchorPane.leftAnchor="0.0">
		</TableView>
	</children>
</AnchorPane>
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.MainWindow">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<MenuBar VBox.vgrow="NEVER">
			<menus>
				<Menu mnemonicParsing="false" text="File">
					<items>
						<MenuItem mnemonicParsing="false" onAction="#handleChangeStorageFile" text="Open File" />
						<MenuItem mnemonicParsing="false" onAction="#handleChangeDirectory" text="Change Directory" />
						<MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
					</items>
				</Menu>
				<Menu mnemonicParsing="false" text="Help">
					<items>
						<MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
					</items>
				</Menu>
			</menus>
		</MenuBar>
		<AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
		<AnchorPane fx:id="statusDisplayPanelPlaceholder" maxHeight="60.0" minHeight="60.0" prefHeight="60.0" VBox.vgrow="NEVER" />
		<AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER" />
		<AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
	</children>
</VBox>
```
###### \resources\view\StatusDisplayPanel.fxml
``` fxml
<HBox maxHeight="-Infinity" maxWidth="-Infinity" minHeight="60.0" minWidth="-Infinity" prefHeight="60.0" prefWidth="720.0" styleClass="status-display-pane" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1" fx:controller="taskle.ui.StatusDisplayPanel">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
      <Label fx:id="displayLabel" styleClass="label-status-display" text="Currently showing:">
         <padding>
            <Insets bottom="16.0" left="16.0" right="16.0" top="16.0" />
         </padding>
      </Label>
		
		<ImageView fx:id="allChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/all_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="overdueChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/overdue_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="pendingChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/pending_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
		<ImageView fx:id="doneChip" fitHeight="45.0" fitWidth="200.0" pickOnBounds="true" preserveRatio="true">
			<image>
				<Image url="@../images/done_chip.png" />
			</image>
			<HBox.margin>
				<Insets bottom="6.0" left="6.0" right="6.0" top="6.0" />
			</HBox.margin>
		</ImageView>
	</children>
</HBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.shape.Rectangle?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1">
	<children>

		<GridPane HBox.hgrow="ALWAYS">
			<columnConstraints>
            <ColumnConstraints hgrow="NEVER" maxWidth="80.0" minWidth="12.0" prefWidth="16.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="148.0" minWidth="30.0" prefWidth="70.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="450.0" minWidth="441.0" prefWidth="441.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="377.0" minWidth="10.0" prefWidth="362.0" />
            <ColumnConstraints maxWidth="495.0" minWidth="432.0" prefWidth="447.0" />
			</columnConstraints>
			<rowConstraints>
				<RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="ALWAYS" />
			</rowConstraints>
			<children>
				<Label fx:id="id" styleClass="cell_big_label" text="\$id" GridPane.columnIndex="1">
               <GridPane.margin>
                  <Insets left="10.0" />
               </GridPane.margin></Label>
				<Label fx:id="name" minWidth="-Infinity" prefWidth="450.0" styleClass="cell_big_label" text="\$name" GridPane.columnIndex="2" />
				<Label fx:id="reminderDate" minWidth="-Infinity" prefHeight="21.0" prefWidth="359.0" styleClass="cell_big_label" text="\$reminderDate" textAlignment="RIGHT" GridPane.columnIndex="3" GridPane.halignment="RIGHT" />
					
				<Label fx:id="details" minWidth="-Infinity" prefHeight="21.0" prefWidth="445.0" styleClass="cell_big_label" text="\$details" GridPane.columnIndex="4" GridPane.halignment="RIGHT" />
            <Rectangle fx:id="colorTag" arcHeight="5.0" arcWidth="5.0" fill="DODGERBLUE" height="50.0" stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0" width="15.0" GridPane.vgrow="ALWAYS" />
			</children>
		</GridPane>
	</children>
	<padding>
		<Insets bottom="10.0" right="10.0" top="10.0" />
	</padding>
</HBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>

<VBox AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0"
	AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0"
	xmlns="http://javafx.com/javafx/8.0.60" xmlns:fx="http://javafx.com/fxml/1"
	fx:controller="taskle.ui.TaskListPanel" stylesheets="@DarkTheme.css">
	<stylesheets>
		<URL value="@DarkTheme.css" />
		<URL value="@Extensions.css" />
	</stylesheets>
	<children>
		<GridPane styleClass="header-grid-pane" HBox.hgrow="ALWAYS">
			<columnConstraints>
				<ColumnConstraints hgrow="NEVER" maxWidth="16.0"
					minWidth="16.0" prefWidth="16.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="72.0"
					minWidth="72.0" prefWidth="72.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="450.0"
					minWidth="450.0" prefWidth="450.0" />
				<ColumnConstraints hgrow="NEVER" maxWidth="360.0"
					minWidth="360.0" prefWidth="360.0" />
				<ColumnConstraints maxWidth="359.0" minWidth="359.0"
					prefWidth="359.0" />
			</columnConstraints>
			<rowConstraints>
				<RowConstraints minHeight="10.0" prefHeight="30.0"
					vgrow="ALWAYS" />
			</rowConstraints>
			<children>
				<Label styleClass="header_label" text="ID"
					GridPane.columnIndex="1" GridPane.halignment="LEFT">
					<GridPane.margin>
						<Insets left="10.0" />
					</GridPane.margin>
				</Label>
				<Label maxWidth="400.0" minWidth="368.0" prefHeight="23.0"
					prefWidth="403.0" styleClass="header_label" text="Name"
					GridPane.columnIndex="2" />
				<Label minWidth="-Infinity" prefHeight="21.0" prefWidth="356.0"
					styleClass="header_label" text="Reminder" GridPane.columnIndex="3"
					GridPane.halignment="LEFT" />

				<Label minWidth="-Infinity" prefWidth="500.0" styleClass="header_label"
					text="Dates" GridPane.columnIndex="4" GridPane.halignment="LEFT" />
			</children>
		</GridPane>

		<ListView fx:id="taskListView" styleClass="anchor-pane"
			VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
